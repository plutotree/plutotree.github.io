[{"categories":null,"content":"对于部署的一些纯前端系统，本身并没有内置用户校验。但是我们又不希望其他用户能无限制使用，所以希望能有简单的用户校验流程。这就需要用到 HTTP Basic Authentication (HTTP 基本认证) 。","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"什么是 HTTP 基本认证 对于部署的一些纯前端系统，本身并没有内置用户校验。但是我们又不希望其他用户能无限制使用，所以希望能有简单的用户校验流程。这就需要用到 HTTP Basic Authentication (HTTP 基本认证) 。 HTTP 基本认证是一种非常简单的认证机制，广泛用于保护 Web 应用的资源。它通过 HTTP Header 传递用户名和密码，并通过 Base64 编码对其进行简单的编码（注意：不是加密）。实际应用中需要配合 HTTPS 使用，以防止明文凭据在网络中被拦截。 ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:1:0","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"HTTP 基本认证的交互流程 客户端请求资源：客户端向服务器发起请求，但未包含认证信息。 服务器返回 401 响应：服务器返回 401 Unauthorized 状态码，同时通过 WWW-Authenticate 头提示客户端需要提供凭证。 客户端提示输入凭证：客户端向用户请求输入用户名和密码。 客户端发送认证信息：客户端将用户名和密码通过 Base64 编码后，添加到 HTTP Header 的 Authorization 服务器验证凭证：服务器解码并验证用户名和密码的正确性。 服务器返回响应： 如果验证成功，返回 200 OK 和资源。 如果验证失败，返回 401 Unauthorized 并要求重新认证。 下面我们用 curl 命令的交互来看下整个流程能更加清晰，可以使用参数-u 来指定用户名和密码，而实际处理中会对用户名和密码计算 MD5，并填充到 Authorization 的 Header 中。 curl --verbose \"https://some.examples.com\" \u003e GET / HTTP/1.1 \u003e Accept: */* \u003e \u003c HTTP/1.1 401 Unauthorized \u003c WWW-Authenticate: Basic realm=\"Need Authorization\" curl -u user:pwd --verbose \"https://some.examples.com\" \u003e GET / HTTP/1.1 \u003e Authorization: Basic Base64ByUserAndPwd \u003e Accept: */* \u003e \u003c HTTP/1.1 200 OK 我们再来看下浏览器中访问效果，对于返回需要校验的网站，浏览器会弹出一个弹框，要求输入用户名和密码： ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:2:0","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"如何在 Nginx 中配置 HTTP 基本认证 ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:3:0","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"创建用户凭据文件 安装 htpasswd 工具： apt-get install apache2-utils 创建新用户，执行命令后输入密码 cd /etc/nginx/conf.d/ htpasswd -c ./auth.htpasswd username 设置文件权限，设置文件所有者和nginx的执行用户一致 chmod 600 auth.htpasswd chown xx:xx auth.htpasswd 可以本地校验下 htpasswd -v ./auth.htpasswd username ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:3:1","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"配置nginx 配置较为简单，只要增加auth_basic和auth_basic_user_file就好了 location / { auth_basic \"Need Authorization\"; # 认证提示内容，显示取决于客户端实现 auth_basic_user_file /etc/nginx/conf.d/auth.htpasswd # 其他的配置 } 配置完成后，重新加载下nginx的配置 systemctl reload nginx ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:3:2","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"测试访问 可以在浏览器中输入网址，访问验证下是否有弹出一个认证窗口，提示用户输入用户名和密码。验证成功后，服务器将正常返回资源，否则会要求重新输入用户名和密码。如果浏览器关闭重新打开后，会要求重新输入。 ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:3:3","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"如何无感登录 增加了这一步骤的确是更安全了，但是每次打开页面需要输入一遍用户名和密码，这又带来了很大的不便。我们可以通过浏览器自带的密码保存，在下次要求认证的时候，直接按登录按钮就好了。 有没有可能更进一步，连登录按钮也不用按，在可信任的电脑上默认帮我登录呢。BitWarden 还真提供了这样的功能，能隐藏式自动填充用户名和密码的功能，这样对使用者就完全无感了。理论上还有种方式可以通过浏览器的插件来直接设置Header。 ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:4:0","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":null,"content":"总结 HTTP 基本认证算是一种最简单有效的认证方式，如果需要更复杂的认证机制，可以考虑其他方式，如 OAuth、JWT 或基于 Session 的认证。 ","date":"2025-04-21","objectID":"/2025/04/http-basic-authentication/:5:0","tags":["http","Authentication"],"title":"HTTP Basic Authentication (HTTP 基本认证)","uri":"/2025/04/http-basic-authentication/"},{"categories":["ai"],"content":"大型模型虽然功能强大，但并非无所不能。自从OpenAI推出工具调用功能后，大型模型的能力边界得到了极大的提升，但这并不是一种通用的解决方案。MCP的出现让我们看到了一种统一和扩展大型模型能力的可能性，特别是在OpenAI宣布全面支持MCP后，这一技术获得了市场的普遍认可。本文致力于通过分享一系列实际案例，让你更深入地理解MCP能够做什么。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:0:0","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"获取各旅游城市近期天气情况 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:1:0","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"低效的传统方案 传统方案不仅耗时费力（通常需要 1 小时以上），还存在较高的人为操作错误风险： ​ 收集城市列表：通过百度搜索手动整理全国旅游城市名录 ​ 采集天气数据 ​：逐个访问天气网站，复制粘贴各城市气象数据 整理数据结果：将零散数据手工整理为结构化表格或 PPT 虽然开发人员可通过编写爬虫或调用 API 优化第 2 步，但面对一次性需求时，代码开发调试的时间成本往往又难以覆盖收益。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:1:1","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"AI 工具的初步尝试 使用 kimi、豆包、元宝等 AI 大模型时，尝试直接提问【整理全国各大旅游城市近期天气情况，以表格形式返回)】看似可行。但是由于缺乏实时的天气数据，结果也就缺乏意义了。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:1:2","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"MCP 标准化解决方案 如果大模型能帮助我们调用 API，那问题就方便解决了，可以 API 接口形式五花八门，有什么办法能统一 API 接口标准呢。MCP（模型控制协议）通过统一接口标准，完美解决了 API 多样性和任务复杂性的矛盾。 下面我们看下集成了天气查询功能的 MCP 后，大模型的回答变化： 提问 ​： 整理全国主要旅游城市最近的天气情况，以表格形式返回，一个城市一行数据 ​ 响应结果 ​（数据已精简）： 城市 日期 白天天气 夜间天气 白天温度 夜间温度 白天风向 夜间风向 白天风力 夜间风力 北京市 2025-04-18 中雨 小雨 19℃ 8℃ 南 南 1-3 级 1-3 级 北京市 2025-04-19 多云 晴 21℃ 11℃ 南 南 1-3 级 1-3 级 上海市 2025-04-18 阴 阴 31℃ 18℃ 东南 东南 1-3 级 1-3 级 上海市 2025-04-19 小雨 小雨 28℃ 17℃ 南 南 1-3 级 1-3 级 广州市 2025-04-18 阵雨 阵雨 28℃ 22℃ 南 南 1-3 级 1-3 级 广州市 2025-04-19 阵雨 多云 28℃ 23℃ 南 南 1-3 级 1-3 级 深圳市 2025-04-18 阴 阴 30℃ 24℃ 东南 东南 1-3 级 1-3 级 深圳市 2025-04-19 阴 阴 30℃ 24℃ 西南 西南 4 级 4 级 查看执行的过程，我们能看到大模型自动发起了多次工具调用，用于查询天气信息。 通过 Cherry-Studio 可直观查看高德地图 MCP 服务的完整能力，天气查询仅是众多标准化接口之一，更主要的是提供路径规划和导航的能力。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:1:3","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"API 聚合平台的 MCP 转型实践 看完前面的的例子，有了 MCP 就能自动调用各类 API，而其能力自然也取决于 API 本身。这时候原来的一些 API 聚合平台是不是就能大显身手了。 下面以ALApi为例来展示下整体流程。 常用的 MCP 服务是用 node.js 和 python 服务为主，而事实上语言不会有限制， 我们只要遵循一定标准规范就好，这个 ALApi 的MCP 服务是用 go 实现的。 账号及权限申请 注册 ALApi 账号，申请 token，申请需要的接口。 服务部署 编译 MCP 服务，编译成功后会生成mcp-alapi-cn.exe git clone \"https://github.com/ALAPI-SDK/mcp-alapi-cn.git\" cd mcp-alapi-cn git build 系统集成 在 Cherry-Studio 中配置 MCP 服务，名称任选，命令填写前面编译来的mlp-alapi-cn.exe全路径，环境变量配置申请的 token 即可。 如果在 Cline、Claude 等其他客户端中配置的话，可以粘贴下述 json（需要和其他的 mcp 配置合并下） { \"mcpServers\": { \"ALAPI\": { \"name\": \"ALAPI\", \"type\": \"stdio\", \"isActive\": true, \"command\": \"D:\\\\xxx\\\\mcp-alapi-cn.exe\", \"args\": [], \"env\": { \"ALAPI_TOKEN\": \"YOUR_API_TOKEN\" } } } } 启用 MCP 配置完成后，Cherry-Studio 中访问的大模型的时候勾选相应的 MCP 服务就可以了 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:2:0","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"应用场景展示 查询油价：执行了一次工具 (api/oil) 查询 查询汇率：执行了四次工具 (api/exchange) 查询 查询黄金等贵金属价格： 通过这种方式，ALApi 上的所有 API 接口，都可以转换成 MCP 服务为大模型所用了。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:2:1","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"背后逻辑 整个流程是如何实现的呢？我们看下代码，可以发现先通过接口 /api/user_apis 获取所有有访问权限的 API 列表（名字、描述、参数列表等），然后将这些 API 依次进行注册。核心注册工具的代码如下： func (s *Server) registerOpenAPITools(doc *openapi3.T) error { toolCount := 0 for path, item := range doc.Paths.Map() { if item.Post != nil { tool := mcp.NewTool(path, mcp.WithDescription(item.Post.Summary)) schema := item.Post.RequestBody.Value.Content[\"application/json\"].Schema requiredParams := make(map[string]bool) for _, required := range schema.Value.Required { requiredParams[required] = true } for paramName, ref := range schema.Value.Properties { description := ref.Value.Description if requiredParams[paramName] { mcp.WithString(paramName, mcp.Description(description), mcp.Required())(\u0026tool) } else { mcp.WithString(paramName, mcp.Description(description))(\u0026tool) } } s.mcpServer.AddTool(tool, s.wrapHandler(s.handler.Handle)) toolCount++ } } if toolCount == 0 { return fmt.Errorf(\"no tools were registered from the OpenAPI spec\") } return nil } ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:2:2","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":["ai"],"content":"总结 MCP 最大的作用是实现了标准化的API接口 ​，建立了统一的交互标准，而更重要的是这一规范得到市场的普遍认可。 ","date":"2025-04-18","objectID":"/2025/04/practical-examples-of-mcp-applications/:3:0","tags":["mcp","ai"],"title":"MCP 实践例子","uri":"/2025/04/practical-examples-of-mcp-applications/"},{"categories":null,"content":"最近将博客从 Jekyll 迁移到 Hugo 了，虽然 Valine 评论系统在 Hugo 中可以直接通过配置文件 hugo.toml 进行设置，但在实际使用中发现了一些坑，以下是整理的解决方案。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:0:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"1. 配置 requiredFields 无效问题 在 Valine 的官方文档中提到，可以通过 requiredFields 配置字段来设置评论时的必填项，比如昵称、邮箱等。然而，在 Hugo 中直接配置后发现该功能无效。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:1:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"问题原因 Hugo 主题下文件 layouts/partials/comment.html 文件中只针对部分字段进行了处理，而没有对 requiredFields 进行正确处理。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:1:1","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"解决方法 将 comment.html 文件复制到项目中相同目录下，然后增加以下代码： {{- with $valine.requiredFields -}} {{- $commentConfig = dict \"requiredFields\" . | dict \"valine\" | merge $commentConfig -}} {{- end -}} ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:1:2","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"2. Gravatar 头像显示问题 在配置头像时发现，随机头像无法正常显示，例如以下头像地址。但是将域名替换为 www.gravatar.com 则可以正常显示。 https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=wavatar\u0026v=1.5.2 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:2:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"问题原因 Gravatar 的中转服务，gravatar.loli.net 存在处理上的问题，导致随机头像无法显示。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:2:1","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"解决方法 由于 Gravatar 的官网在国内访问存在较多问题，更换了另一个 Gravatar 的中转服务： cn.gravatar.com。在配置文件中增加 avatar_cdn 之后，发现这个配置不生效。需要增加类似的处理逻辑，修改 comment.html 文件： {{- with $valine.avatar_cdn -}} {{- $commentConfig = dict \"avatar_cdn\" . | dict \"valine\" | merge $commentConfig -}} {{- end -}} 修改后，Gravatar 头像和随机头像的显示恢复正常，但邮箱为空时随机头像无法随机。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:2:2","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"邮箱为空时头像并不会随机 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:3:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"问题原因 获取随机头像的 MD5 是根据邮箱地址进行生成，而邮箱地址为空时其生成的 MD5 是固定的，这也导致获取的也都是固定头像。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:3:1","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"解决方法 将 valine.min.js 中的 t.get(\"mail\") 修改为 t.get(\"mail\") || t.get(\"nick\")，即邮箱为空时使用昵称计算随机头像。修改后需要将文件发布到 CDN 才能使用，具体步骤不在此赘述。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:3:2","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"QQ 头像和昵称获取问题 在 Valine 中，昵称字段输入 QQ 时，预期是可以获取 QQ 头像和昵称的，但是实际测试的时候却无法正确获取。在 Chrome 的调试窗口，可以看到访问第三方的 API 地址的时候会报错： https://api.qjqq.cn/api/qqinfo?qq=12345 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:4:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"问题原因 就在写该文章的几天前直接在浏览器中访问这个地址还是正常的，不过会因为跨域问题而导致在 Valine 中无法正常使用。今天访问这个地址，发现这个服务已经无法访问了，页面会跳转到一个 API 服务平台奶思猫。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:4:1","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"解决方法 在网站上搜索后，发现有免费的QQ 信息服务接口。这个 API 的回包结构和 Valine 中使用的 api.qjqq.cn 是不一致的。由于原来的接口已经下线，正确的回包结构目前也不清楚。好在现在有强大的 AI，直接把压缩的 JS 代码丢给 AI，它就能分析出原来处理 QQ 头像和昵称的逻辑。 var a = function (e, t) { var n = i.default.store.get(o.QQCacheKey); n \u0026\u0026 n.qq == e ? t \u0026\u0026 t(n) : i.default .ajax({ url: \"https://api.nsmao.net/api/qq/query?key=xx\u0026qq=\" + e, method: \"get\", }) .then(function (e) { return e.json(); }) .then(function (n) { if (200 == n.code) { var r = n.data.nick, a = n.data.avatar, u = { nick: r, qq: e, pic: a, }; i.default.store.set(o.QQCacheKey, u), t \u0026\u0026 t(u); } }); }; 我们有两种方案分别是在客户端直接修改和在服务端进行中转： 方案 1：修改 Valine 中请求的 url 以及回包解析逻辑。方案修改起来很容易，最大的问题是会暴露了密钥。 修改请求 URL：api.njqq.cn/api/qqinfo?qq=xxx 修改成 https://api.nsmao.net/api/qq/query?key=xx\u0026qq= 修改昵称和头像的获取：{var r=n.name,a=n.imgurl 修改成 {var r=n.data.nick,a=n.data.avatar。 方案 2：后台提供中转服务 通过自己的服务器封装中转接口，避免密钥暴露，接口可以丢给 AI 实现，但需要额外的服务维护成本。 下面是用 golang 实现的获取QQ资料的 HTTP 服务，功能就是将奶思猫提供的 QQ 资料的API接口转换成适配Valine的格式。需要设置下密钥和访问端口。 package main import ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"os\" ) // APIResponse represents the response from the QQ API type APIResponse struct { Code int `json:\"code\"` Msg string `json:\"msg\"` Data QQData `json:\"data\"` ExecTime float64 `json:\"exec_time\"` IP string `json:\"ip\"` } // QQData represents the data field in the API response type QQData struct { Nick string `json:\"nick\"` Qid string `json:\"qid\"` RegTime string `json:\"regTime\"` Level int `json:\"level\"` Avatar string `json:\"avatar\"` Email string `json:\"email\"` IsVip bool `json:\"is_vip\"` IsYearsVip bool `json:\"is_years_vip\"` VipLevel int `json:\"vip_level\"` } // ClientResponse represents the response we'll send to the client type ClientResponse struct { Code int `json:\"code\"` Name string `json:\"name\"` ImgURL string `json:\"imgurl\"` Email string `json:\"email\"` } func main() { // Get the API key from environment variable or use default apiKey := os.Getenv(\"QQ_API_KEY\") if apiKey == \"\" { apiKey = \"MY_KEY\" // Default key for development } http.HandleFunc(\"/qq_api/qqinfo\", func(w http.ResponseWriter, r *http.Request) { // Get QQ number from query parameter qqNumber := r.URL.Query().Get(\"qq\") if qqNumber == \"\" { http.Error(w, \"Missing qq parameter\", http.StatusBadRequest) return } // Construct the API URL apiURL := fmt.Sprintf(\"https://api.nsmao.net/api/qq/query?key=%s\u0026qq=%s\", apiKey, qqNumber) // Make the request to the QQ API resp, err := http.Get(apiURL) if err != nil { log.Printf(\"Error making request to QQ API: %v\", err) http.Error(w, \"Failed to fetch QQ information\", http.StatusInternalServerError) return } defer resp.Body.Close() // Read the response body body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Printf(\"Error reading response body: %v\", err) http.Error(w, \"Failed to read QQ information\", http.StatusInternalServerError) return } // Parse the API response var apiResp APIResponse if err := json.Unmarshal(body, \u0026apiResp); err != nil { log.Printf(\"Error parsing API response: %v\", err) http.Error(w, \"Failed to parse QQ information\", http.StatusInternalServerError) return } // Prepare the client response clientResp := ClientResponse{ Code: 200, Name: \"\", ImgURL: \"\", Email: \"\", } // Only populate the fields if the API request was successful if apiResp.Code == 200 { clientResp.Name = apiResp.Data.Nick clientResp.ImgURL = apiResp.Data.Avatar clientResp.Email = apiResp.Data.Email } else { // If the API request failed, pass along the error code clientResp.Code = apiResp.Code log.Printf(\"API returned error: %s\", apiResp.Msg) } // Set content type header w.Header().Set(\"Content-Type\", \"application/json\") // Encode and send the response if err := json.NewEncoder(w).Encode(clientResp); err != nil { log.Printf(\"Error encoding client response: %v\", err) http.Error(w, \"Failed to encode response\", http.StatusInternalServerError) return } }) // Start the HTTP server port := os.Getenv(\"PORT\") if port == \"\" { port = \"52101\" // Default port } log.Printf(\"Starting server on port %s\", port) if err := http.ListenAndServe(\":\"+port,","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:4:2","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"评论数据迁移 如果 URL 没有改变，评论数据是无需处理的。如果 URL 发生了变化，并且你想保留之前的评论数据，那就需要手动进行迁移。 Valine 的所有数据是存储在 LeanCloud 中，可以很方便地通过脚本进行修改。 不过因为我的评论量少得可怜，我就直接手动修改了。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:5:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"总结 Valine 评论系统现在已经基于处理停止维护的状态了，而且新的版本源友也没有完全开源的服务，存在较大的局限性。未来如果有时间的话，升级 Waline 似乎是一个比较好的选择。Waline 不仅功能更完善，还提供了更好的国内访问体验和开源支持。另外最大的差异其实是 Waline 是需要后台服务，这一点可以说是优点，也可以说是限制。 ","date":"2025-04-10","objectID":"/2025/04/migrate-from-jekyll-to-hugo/:6:0","tags":["jekyll","hugo"],"title":"博客从 Jekyll 迁移到 Hugo：Valine评论系统相关问题","uri":"/2025/04/migrate-from-jekyll-to-hugo/"},{"categories":null,"content":"在 Windows 和 Mac 使用了 Rime 输入法已经有一段时间了，最近随着“仓输入法”稳定性的增强和功能的完善，iPhone 上也终于切换到 Rime 家族了。面对新的输入法，开始思考形码与音码的选择。实践中如何在 PC、Mac 和 iPhone 上进行配置和数据的自动同步，继续 Rime 的折腾之路吧。","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"初见“仓输入法” 在 windows 和 mac 使用了 Rime 输入法已经有一段时间了，但是手机上的iRime并不完善，更新也不频繁。iOS 系统关闭了网络权限，在输入法隐私上这点是有保障的。直到最近接触到仓输入法，发现功能已经做得很完善了。它不仅内置了雾凇拼音等优秀输入方案，还提供了数据同步和词表更新的完善解决方案。这促使我下定决心，完成全平台输入法 RIME 统一化的最后一环。 ","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/:1:0","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"上手“仓输入法” 对于不想深入研究配置细节的用户，仓输入法的新手友好度相当高。我选择保留 26 键布局，以无缝迁移电脑端配置，避免重新适应 9 键布局。习惯了从 Nokia 时代的 T9 输入法，我能够实现高速单手盲打，但现在是时候转变了。仓输入法的上下左右划动设定，极大地扩展了单键输入内容的可能性，使得快捷输入变得异常方便。。我们可以很方便在一个 26 键字母键盘上加上数字，及大量的标点符号。快捷输入（手机号、邮箱地址、车牌号等等）真的很方便，相比起电脑上之前的 v 模式，这个下划真的就是那么一下就搞定了。此外，我们还可以增加很多系统命令，复制、粘贴、剪切等，以及输入法的方案切换等等。 键盘配置方面，官方文档尚需完善。注意区分字符（symbols）和符号（characters），只有符号才支持 Rime 处理。此外，确保勾选了“经过 Rime 处理”选项。 除了键盘配置之外，其他的配置和 PC 端是完全一致的，基本上可以直接复用 PC 端配置。将 PC 端配置打包发到手机后，导入到仓输入法基本就能生效了。 ","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/:2:0","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"想念“五笔输入” 看群里还蛮多人钟情于五笔 86 的人，想起自己也算是最早一代使用五笔的人，直到后面拼音输入法联想功能的完善，尤其在引入在线提示词之后，常用语的打字速度上五笔已经处于劣势了，我才逐步切换到了搜狗拼音输入法。 这么想起来有 8 年没有使用过五笔输入了，这似乎是有点遗憾。 我开始折腾起五笔输入法了，先拿五笔做了反差来用吧。首先想要找一份简体的五笔单字码表，有人推荐了WubiLex，还是相当好用的，自带大量的五笔词库。开始选择了微软五笔的单字，后面发现很多字都不支持，比如羴之类的。既然要作为反查词库，那么词库必须完整啊。后面用了 WubiLex 自带的五笔单字库，字库看起来还是比较完整的。现在五笔可以作为不认识字的反查，也可以想念的时候切换打打字。原以为五笔打字是刻在骨子里面的，不过竟然有点忘记最后一笔的规则了，看来时间还真是会让人忘却。 ","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/:3:0","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"再聊聊“双拼输入” 在研究五笔输入法的时候，同时也看看其他的形码输入法，目前比较多人推崇的是小鹤音形，不过现在对新的形码输入并没有啥兴趣了。不过在过程中看到有人在说，“双拼输入法是投入性价比最高的输入法了，花上几个小时就能熟悉，花上几天就能赶上原来的拼音输入速度了，而且是一辈子受益的”。理论上，双拼能显著降低击键次数和输入错误率。我是否应该花时间学习双拼输入呢？。推荐下这篇文章让双拼不再是只属于少数人的输入方式。 双拼方案众多，主要区别在于是否使用;键。搜狗和微软双拼用了;做ing的输入，而自然码和小鹤并没有去用;。我更喜欢后者，小鹤算是在自然码上做了一些改进，尽管这个改进有很多作者自己的因素在里面。花了十几分钟去做打字练习，发现完全没有记住，不过我下载了一张键位图放在桌面了，以后还是会试一试的。顺便推荐一个这个双拼在线练习的网站，提供了各种不同的双拼方案的在线练习，另外还有提供小程序。 双拼在线练习 另我还发现了双拼方案评测工具，它根据击键手指、位置和过程预估打字时间，评估分数，并提供优化方案。理论上，我们可以根据数据设计出最高效的双拼输入法。 双拼方案评测工具 在对不同双拼方案进行比较后，发现主流方案之间的差异不大，从 114.9 到 123.6，差异在 10%不到，简单看数据，相比全拼输入法大概能有 20%-30%的速度提升吧。但是“飞猫”和“乱序”从分数上看却是遥遥领先，这是为啥呢？ 双拼方案 分数 拼音加加 123.6 国标双拼 119.9 小鹤双拼 118.8 微软 117.9 自然码 116.6 紫光 126.5 智能 ABC 114.9 大牛 131 飞猫 174.5 全拼 93.3 乱序优化 182.2 我们先来看下“飞猫”和“乱序优化”的键位图。有没有发现和其他双拼输入法很明显的差异，他们的声母是乱序的，你不仅需要记住韵母，还得重新去记声母。通过这一点，能比其他双拼输入法的输入速度再继续提升 30%。而“飞猫”还有一个特点在于部分拼音是支持多个键的，就是所谓的“飞键”，比如sh既可以通过N也可以通过A进行输入，你哪个手指方便就用哪个手指去打印，有点像是按Shift键的感觉，你左手打字母那就右手按右边的Shift，反之亦然。不过我估计挺多人没有遵守这个基础打字规范，我个人大部分情况还是遵循了这一点的。 飞猫键位图 乱序优化键位图 网上关于“飞猫”的资料相当少，这一篇算是作者在 2016 年发的原文，的确是通过程序计算出来的按键，可是后面就没啥新内容了。GitHub 上也没有其他资料，只有这一篇写到在 Rime 中的飞猫配置。下面这些是作者文章中的截图。 ","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/:4:0","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"多端数据同步方案 我们需要同步的数据，可以分为几类： 配置类 yaml 文件； 词库类 yaml 文件； 用户输入词库，以 userdb 格式保存； 我们先看前两类数据的同步方案，这里的数据源头是维护在 Git 仓库的。 在看用户词库的同步方案，这里的数据源头的话就是各个输入设备的本地数据，执行同步操作后会将自己设备的数据写入微云同步盘的指定目录，同时读取其他设备的用户词库进行合并处理。 这里相关的脚本操作在 Mac 和 Windows 上是在 uTools 的快捷命令插件中进行维护，开启了定时执行，手机端是通过 iPhone 的快捷指令进行定时执行。而源头的词库是通过 Github Workflow 进行定时更新的，这样整体流程都不需要人工干预了。 ","date":"2024-07-02","objectID":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/:5:0","tags":["rime"],"title":"继续折腾Rime：iOS版仓输入法及多端数据同步流程","uri":"/2024/07/introduction-to-hamster-and-multi-device-data-synchronization/"},{"categories":null,"content":"通过部署 Cronicle 实现了定时任务可视化的管理，并利用其API功能搭建自动化流程。结合 n8n 工作流平台，可以用 GitHub Webhook 触发同步任务，这样就能实现博客和仓库的自动化同步更新流程，基于 n8n，我们还能探索更多的自动化工作流。","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":null,"content":"最近又开始折腾起我的服务器了，重点关注数据更新流程中的一些不满意之处： Git仓库同步更新：广州和香港的服务器通过crontab任务每分钟执行git pull操作； 博客同步更新：服务器上的crontab任务执行git fetch，对比差异后触发构建流程； Cronicle部署：广州服务器未部署cronicle，导致定时脚本依赖crontab，无法在页面查看执行状态 ","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/:0:0","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":null,"content":"部署cronicle 为了简化广州服务器上的定时任务管理，我部署了 Cronicle。尽管步骤较多，但得益于之前的经验，十几分钟内便完成了： 申请并配置域名，设置 CNAME 转发； 配置 Nginx，申请 HTTPS 证书； 安装Cronicle（未使用Docker，直接通过curl命令）； 修改配置文件，参照香港服务器； 启动Cronicle； 在页面配置任务，如进程监控脚本等； 部署过程中发现，Cronicle支持API远程访问，这正是我一直期望的功能。考虑到直接在机器上部署agent来转发命令存在安全隐患，且定制化配置页面需要额外维护，cronicle的API很好的满足了我。 ","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/:0:1","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":null,"content":"部署n8n 有了Cronicle的API，我们具备了通过GitHub push webhook触发同步更新的基础。接下来，需要找到一个合适的服务接收webhook请求，并优雅地调用我们的API接口。这时，我想起了持续集成（CI）的概念。曾尝试使用集简云等服务，但它们通常按执行次数收费且价格不菲。经过一番搜索，我发现n8n受到了许多人的推荐。其插件生态完善，能方便地集成主流服务。 部署n8n相对简单： 申请域名，配置CNAME转发； 配置Nginx，申请HTTPS证书； 使用Docker部署n8n； ","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/:0:2","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":null,"content":"借助n8n实现git仓库的同步更新 配置流水线花费了一些时间，没找到直接参考的例子，只能一步步琢探索。 第一步：引入GitHub Trigger节点，配置了token之后，只看到一个Test step的按钮。点击之后，n8n能自动配置GitHub的Webhook的配置项。n8n区分了测试和正式的webhook地址，注意的是对于正式地址仍然需要手动在GitHub页面配置的。 第二步：引入HTTP request节点，调用cronicle的API。 简单测试了下发现流程就可以跑通了，但是这里的流水线没有对API执行的结果做回包解析。所以第三不便是需要引入Code节点，判断下下错误码，对于非0的情况直接抛异常了。 code=$input.item.json.code if (code !== 0) { throw new Error(`HTTP request failed with code {data[0].code}`) } return $input.item; 整体流水线的配置，只包含三类节点 ","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/:0:3","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":null,"content":"实现博客的同步更新 有了git仓库同步的经验，要解决博客的同步更新其实就比较简单了。不过这里顺便提下n8n的消息通知并不优雅，没有地方统一配置成功和失败的消息发送。目前来看需要针对每一条流水线进行配置。 后续会将更多任务挪到n8n上面来，这只是一个起步。 ","date":"2024-06-16","objectID":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/:0:4","tags":["cronicle","n8n"],"title":"从 Cronicle 到 n8n 实践自动化工作流","uri":"/2024/06/from-cronicle-to-n8n-as-workflow-solution/"},{"categories":["My Life"],"content":"本文记录了我为减肥数据可视化所做的技术探索。基于Echarts开发了动态图表，采用无极平台实现云端表格编辑和API调用，最后结合GitHub自动化部署，搭建出可在线更新的数据看板。","date":"2024-06-16","objectID":"/2024/06/lose-weight-data-visualization/","tags":["lose weight","life"],"title":"减肥数据可视化","uri":"/2024/06/lose-weight-data-visualization/"},{"categories":["My Life"],"content":"最近，我踏上了减肥的征程，并在过去一个月里取得了小小成果。不过这里重要不是减肥，而是我需要一种方式来直观展示我的减肥进展，其实最主要的也就是体重数据的折线图。但市面上的多数健康追踪应用似乎都未能满足我的需要，它们提供的图表功能缺乏对时间选择的灵活性——大多数应用仅支持以自然日、周或月为单位的折线图展示，其实我需要的也就是我从减肥开始到现在一个区间段的数据变化而已。 我决定自己动手制作图表。在众多图表库中，Echarts 以其美观和功能强大脱颖而出，经过一番尝试，我发现它几乎可以满足我所有的需求。 我曾幻想能够直接在网页上读取我的 iPhone 健康数据，但苹果的 HealthKit 似乎并未对网页端开放，这让我不得不另辟蹊径。我选择了从手机导出所有健康数据，然后在电脑上进行处理，再将其导出为便于网页使用的格式。 最初，我将数据以 HTML 的形式维护在 git 仓库中，每当有更新时，GitHub 的 workflow 会自动触发并部署更新。这种方法基本上能满足我的需求了。 只是想到数据放在 HTML 中不是一个太好的解决方案，我就尝试将数据从 HTML 中独立出来，转而使用 JSON 格式存储。这样一来，每当需要更新数据时，我只需修改 JSON 文件，而无需触碰 HTML 代码，这并未将我的工作简化，但是听起来更合理不是？ 我很快意识到，即使是 JSON，也仍然需要通过 git 提交，这并不是我所追求的优雅解决方案。我希望能够在网页上直接编辑数据，于是开始探索不同的方案。最终，我发现了一个完美的解决方案——无极。它不仅提供了一个可视化的表格数据编辑界面，还有数据拉取的 API 接口，而且是完全免费的。尽管我对其可能存在的使用限制尚不明确，但它已经很好地满足了我的需求。 在部署过程中，我遇到了一个棘手的问题：无极提供的 API 接口存在跨域访问的问题。为了解决这个问题，我不得不设置了一个 nginx 服务器作为中转，虽然这增加了一些复杂性，但最终确保了数据的顺利传输和展示。 这纯粹是一趟折腾之旅，不过好在不管是 GitHub 的流水线更新流程，还是 Nginx 服务器也都是现成的，所以工作量倒是不大。最后还是展现下我的趋势图吧，网址就先不贴了。 ","date":"2024-06-16","objectID":"/2024/06/lose-weight-data-visualization/:0:0","tags":["lose weight","life"],"title":"减肥数据可视化","uri":"/2024/06/lose-weight-data-visualization/"},{"categories":null,"content":"最近鼠须管squirrel升级之后选项变成纵向排列了，本地没有改过配置，那应该就是新版本对style/horizontal参数不再兼容了，看了下 Release notes 果然如此，这里备注下这两个选项配置不同情况下的效果。一般只需要设置 candidate_list_layout: linear 即可。 candidate_list_layout: linear text_orientation: vertical candidate_list_layout: linear text_orientation: horizontal candidate_list_layout: stacked text_orientation: horizontal candidate_list_layout: stacked text_orientation: vertical ","date":"2024-06-13","objectID":"/2024/06/squirrel-skin-horizonetal-conf/:0:0","tags":["rime","squirrel"],"title":"鼠须管 Squirrel 选项词横排配置调整","uri":"/2024/06/squirrel-skin-horizonetal-conf/"},{"categories":null,"content":"开源输入法的好处就是可以定制自己的输入方案，选择喜欢的词库，甚至程序化方式生成专业词库。这篇文章介绍了我使用的词库来源及更新流程。","date":"2024-01-23","objectID":"/2024/01/my-rime-dict/","tags":["rime"],"title":"我的 RIME 词库说明","uri":"/2024/01/my-rime-dict/"},{"categories":null,"content":"最开始用的基础词库来源于ssnhd/rime，这是它的词表介绍 主要用了这几份词库： luna_pinyin.dict.yaml：默认字库，有部分的词语，总计7万； luna_pinyin.sogou.dict.yaml：来源于搜狗词库，总计105万； easy_en.dict.yaml：英文词库，总计11万； 此外还用了几份自己维护的词库： 股票名称列表，使用Tushare API拉取A股的股票名称列表生成词库，总计5千； 我的搜狗自定义词库，从搜狗导出后经过手动删除，总计3千； 我手动维护的词库，总计1百； 但是这份词库存在几个问题： 缺乏词库持续的更新维护； 这份百万级的搜狗词库质量不高，并不是搜狗自带的词库； 本身基于繁体，尽管这符合RIME的做法； 最近发现两份还不错的简体词库，分别是四叶草拼音和雾凇拼音。其中雾凇拼音有6K的star数量，并且更新还是比较及时的，提供的功能也比较完善，下面是一个功能介绍： 作者也明确说明了他会长期维护几份词库： 8105 字表。 base 基础词库。 ext 扩展词库，小词库。 tencent 扩展词库，大词库。 Emoji 雾凇拼音用了大量的lua脚本来实现功能，这里先不整体引用，打算只引用词库。但是在部署的时候却发现小狼毫会一直处于加载中，尝试后发现是在加载Tencent大词库的时候才出问题。搜索Github发现可以关掉配置use_preset_vocabulary就可以解决问题。 目前使用的外部词库保留了来源于雾凇拼音的四份中文词库 cn_dicts/8105 # 字表 cn_dicts/base # 基础词库 cn_dicts/ext # 扩展词库 cn_dicts/tencent # 腾讯词向量 ","date":"2024-01-23","objectID":"/2024/01/my-rime-dict/:0:0","tags":["rime"],"title":"我的 RIME 词库说明","uri":"/2024/01/my-rime-dict/"},{"categories":null,"content":"从typora早起的beta版就开始在用，现在应该越来越多人认可其作为最佳Markdown编辑器。不过默认情况下，在windows展示的字体使用的是宋体，看起来其实不太美观，我们可以换成其它更好看得字体。微软雅黑我最不满意的是中文标点符号太丑，甚至不太容易分辨，我还是比较喜欢思源黑体。 在Typora的设置页中打开主题文件夹，然后新建一个 xx.user.css 文件（xx为你的主题名称），比如使用的主题为github，则新建一个 github.user.css 文件，里面的内容填写如下： body { font-family: \"Source Han Sans SC\", \"Microsoft Yahei\"; } header, .context-menu, .megamenu-content, footer{ font-family: \"Source Han Sans SC\", \"Microsoft Yahei\"; } .md-fences, tt, code { font-family: Consolas; } 这里其实就是修改了字体为思源黑体、微软雅黑，以及代码字体为 Consolas。关于思源字体的介绍，可以参考之前发表的文章。重新打开Typora，或者切换其它主题再切换回来就可以生效了。最近新装了Windows11， 把常用软件都切换成了深色界面了，Typora也换成了官方的Night主题。 顺便补充一点，字体的英文名可以通过 Exif 查看工具（比如 exif-tool 命令行工具或者在线工具也行）获取真实的 font-family，在windows的字体设置中展示的是中文font-family，实测并不可用。 ","date":"2024-01-22","objectID":"/2024/01/modify-typora-font/:0:0","tags":["typora"],"title":"修改 Typora 的字体","uri":"/2024/01/modify-typora-font/"},{"categories":["Software"],"content":"如果有在 Mac 下用过HomeBrew的都知道，软件安装起来是多么方便。Windows 一直缺少这么方便的包管理工具。Chocolatey只能算是便捷的安装工具，和包管理工具差距还挺大的。WinGet可以算是一个包管理工具，只是目前支持的应用还比较少。以前有听说过Scoop，印象中说法是支持的软件数量较少。不过最近试了下，发现其支持的软件数量已经相当广泛。各类常见开发工具自然不必说了，主流的软件其中包括部分国内软件都能在官方的 bucket 中找到。官方不支持的软件，我们也能通过第三方的 bucket 进行安装。目前我有 59 个软件是通过 scoop 进行安装了。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:0:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"Scoop 操作示例 安装 scoop Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression 安装main的软件 scoop install go scoop install nodejs 安装extra的软件 （也是官方维护，要求比main宽松） scoop bucket add extras scoop install extras/apifox 安装第三方软件（这是我自己的 bucket 哈） scoop bucket add plutotree https://github.com/plutotree/scoop-bucket scoop install plutotree/qqmusic 安装字体 scoop bucket add nerd-font scoop install hack-nf 更新所有软件 scoop update scoop update * 安装流程和 Mac 下的 Homebrew 相似，scoop 用 json 来维护软件信息，做法也是和老版本的 homebrew 一样。不过 scoop 有点优势在于，绝大部分软件都能支持自动更新，官方也提供了 Github Action 组件，定时检测发现有新版本的时候会自动更新描述文件。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:1:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"Scoop 使用说明 使用自定义目录进行安装 [environment]::setEnvironmentVariable('SCOOP', 'E:\\Scoop', 'User') $env:SCOOP='E:\\Scoop' # 如果不用这句话的话可以重开窗口也行 iex (new-object net.webclient).downloadstring('https://get.scoop.sh') 增加常用的 bucket，可以参考官方介绍的bucket 列表（质量比较高），我目前只加了 extra 和 nerd-fonts scoop bucket add extra scoop bucket add nerd-fonts 安装官方推荐的加速下载工具 aria2 scoop install aria2 从控制面版卸载不需要的程序，然后通过 scoop 进行安装和管理。 查找：scoop search xx 安装： scoop install xx 卸载：scoop uninstall xx 升级: scoop update; scoop update xx 查看缓存（下载的安装包）：scoop cache 删除缓存：scoop cache rm xx （*表示所有软件） 查看已安装软件：scoop list 删除软件的旧版本：scoop cleanup xx （*表示所有软件） 删除软件的旧版本同时清理缓存：scoop cleanup -k xx（*表示所有软件） ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:2:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"哪些软件不适合 绿色软件是更适合的，而和系统关联性太强的软件是不适合的，尤其是需要管理员权限进行安装的。尽管 scoop 也支持使用管理权限进行安装，但是同样更新和卸载也许要管理权限，我觉得就没必要了而且维护起来会比较麻烦。 目前就我电脑上的软件而言，没有使用 scoop 管理的主要是： 系统驱动和厂商管理工具，比如 Nvidia、HP 等管理工具； 微软的开发工具和环境依赖，比如Microsoft Visual C++ xx Redistributables、Microsoft Windows Desktop Runtime等； 微软自带的部分商店应用，比如主题、微软 TODO 工具、画图工具、3D 查看器等； 和系统关联系比较大，或者不方便迁移出来的，比如 Adobe 系列、Office 软件、iTunes、输入法等； 平台类软件，需要使用其更新管理，比如 steam、Epic 等，后续需要研究下； 专业软件，或者内部使用的软件； 部分还没来得及迁移的软件，比如 TortoseSVN、QQ、微云等； ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:2:1","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"查找软件 可以使用命令scoop search进行搜索，不过建议是在官网进行搜索，需要注意的是选项Official bucket only选项是否开启，一般情况下是建议安装官方包，以及可信赖的第三方。而我个人而言，第三方目前会控制在自己的 bucket 范围。 在官方查找不到的时候，可以扩展到第三方，找到之后可以修改后何如自己的 bucket 中。第三方的 bucket 其实质量并一定能保证，最后看下描述文件内容，以及是否从官网下载。还有部分维护破解软件的第三方 bucket，建议就不要使用了。还有就是关注下 bucket 的 star 数量，毕竟 star 多点还是稍微靠谱点。这个网站提供按 star 数量排名的 bucket 列表，也可以参考下，蛮多是中国人维护的 bucket。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:2:2","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"维护自己的 bucket 创建一个自己的 bucket 在 GitHub 上直接通过Bucket 模板新建一个仓库； 按照提示说明，修改仓库的设置，开启读写权限； 修改几个文件的占位符，指定下仓库名信息； 维护自己软件的描述信息， 自己写应用描述信息，或者直接复用第三方，或者在其基础上修改； 增加自己的 bucket：scoop bucket add BUCKET_NAME YOUR_BUCKET_GIT_ADDRESS 安装自己的软件：scoop install BUCKET_NAME/APP_NAME ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:3:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"应用描述信息 这块算是 scoop 中最复杂的内容了，官方文档提供了基础的介绍，更有用的话应该需要多参考已有的描述。我们来看几个例子 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:4:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"Cos-Browser { \"version\": \"2.11.13\", \"description\": \"A visualization interface tool provided by Tencent Cloud COS, view, transfer, and manage COS resources easily\", \"homepage\": \"https://github.com/tencentyun/cosbrowser\", \"license\": \"Freeware\", \"url\": \"https://cos5.cloud.tencent.com/cosbrowser/cosbrowser-setup-2.11.13.exe#/dl.7z\", \"hash\": \"sha512:0063411445cc4a2af098b71780525ec2e190f396934d1b910fbd62aea897ce99a0b2099a848d15df871e7f774aa7334be6acd2c4c4de2e9d0ae8cce05830940f\", \"architecture\": { \"64bit\": { \"pre_install\": \"Expand-7zipArchive \\\"$dir\\\\`$PLUGINSDIR\\\\app-64.7z\\\" \\\"$dir\\\"\" }, \"32bit\": { \"pre_install\": \"Expand-7zipArchive \\\"$dir\\\\`$PLUGINSDIR\\\\app-32.7z\\\" \\\"$dir\\\"\" } }, \"post_install\": \"Remove-Item \\\"$dir\\\\`$*\\\" -Force -Recurse\", \"shortcuts\": [ [\"cosbrowser.exe\", \"COSBrowser\", \"--user-data-dir=\\\"$dir\\\\UserData\\\"\"] ], \"persist\": \"UserData\", \"checkver\": { \"url\": \"https://cos5.cloud.tencent.com/cosbrowser/latest.yml\", \"regex\": \"version: ([\\\\d.]+)\" }, \"autoupdate\": { \"url\": \"https://cos5.cloud.tencent.com/cosbrowser/cosbrowser-setup-$version.exe#/dl.7z\", \"hash\": { \"url\": \"$baseurl/latest.yml\", \"regex\": \"sha512: $base64\" } } } 看下整体流程： 下载指定 URL，下载后进行 Hash 校验； URL 后面有#/dl.7z，在校验成功后会直接使用 7zip 进行解压缩； 调用pre_install脚本内容，这里使用了Expand-7zipArchive解压缩； 调用install脚本内容，这个应用是空的； 创建快捷方式，这里关注下有指定参数--user-data-dir，这样就不会使用系统的AppData目录了。猜测这个参数是 electron 开发的软件都会有的，其它框架开发的就不支持了。 调用post_install脚本内容，这里主要就是删除一些无用的文件； persist指定了需要持久化的目录，scoop 会帮忙创建一个链接，并且卸载的时候不会删除； checkver 是用来检测是否有新版本，autoupdate 是用来在有新版本的时候进行下载并且更新描述文件。这两块的细节内容会比较复杂点，可以参考官方文档。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:4:1","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"Evernote { \"version\": \"10.71.2\", \"description\": \"[Evernote] Use it for note taking, project planning and organize everything\", \"homepage\": \"https://evernote.com\", \"license\": \"Freeware\", \"url\": \"https://win.desktop.evernote.com/builds/Evernote-latest.exe#/dl.zip\", \"hash\": \"7e3b3565651b6ddeaa9dfb86502951917d996b09ebd32f2ce11509325d3bcce1\", \"architecture\": { \"64bit\": { \"pre_install\": \"Expand-7zipArchive \\\"$dir\\\\`$PLUGINSDIR\\\\app-64.7z\\\" \\\"$dir\\\"\" }, \"32bit\": { \"pre_install\": \"Expand-7zipArchive \\\"$dir\\\\`$PLUGINSDIR\\\\app-32.7z\\\" \\\"$dir\\\"\" } }, \"post_install\": \"Remove-Item \\\"$dir\\\\`$*\\\" -Force -Recurse\", \"shortcuts\": [[\"Evernote.exe\", \"Evernote\"]], \"checkver\": { \"url\": \"https://evernote.com/release-notes\", \"regex\": \"Version.*?([\\\\d.]+)\" }, \"autoupdate\": { \"url\": \"https://win.desktop.evernote.com/builds/Evernote-latest.exe#/dl.zip\" } } 基本上和 Cos-Browser 的信息是类似的，但是 autoupdate 这里没有指定 Hash 获取方式，其实是官方没有提供，这种情况下的话就只能等文件下载完成之后再进行 hash 计算了，理论上来说是存在文件下载异常描述信息有问题的，这种的话就只能等发现之后手动修复了。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:4:2","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"QQ 音乐 { \"##\": \"QQ音乐\", \"version\": \"20.05.0\", \"description\": \"[QQ音乐] 千万正版音乐海量无损曲库新歌热歌天天畅听的高品质音乐平台\", \"homepage\": \"https://y.qq.com\", \"license\": \"Freeware\", \"url\": \"https://dldir1.qq.com/music/clntupate/QQMusic_YQQWinPCDL.exe#/dl.7z\", \"hash\": \"4c35742f11a011e8aff31987966e29b014fcdabfd6f50240125c8252f86188b2\", \"post_install\": \"Copy-Item \\\"$dir\\\\QQMusic.tpc\\\" \\\"$dir\\\\instok\\\"\", \"checkver\": { \"url\": \"https://y.qq.com/download/download.html\", \"regex\": \"Windows PC.*\\\\:([\\\\d.]+)\" }, \"shortcuts\": [ [\"QQMusic.exe\", \"QQ音乐\"], [\"QQMusic.exe\", \"QQ Music\"] ], \"autoupdate\": { \"url\": \"https://dldir1.qq.com/music/clntupate/QQMusic_YQQWinPCDL.exe#/dl.7z\" } } 这里我们创建了两个快捷方式，分别是 QQ 音乐和QQ Music，这样不管输入的是哪个都能启动了。同样 QQ 音乐也没提供 hash 获取方式，只能下载后本地计算。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:4:3","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"补充说明 腾讯会议比较奇怪，不能直接在current目录启动，而必须在版本目录启动，所以就不能用自带的快捷方式，而需要手动创建了。 { \"pre_install\": [ \"Rename-Item \\\"$dir\\\\`$_*_\\\" \\\"$dir\\\\$version\\\"\", \"Remove-Item \\\"$dir\\\\`$*\\\",\\\"$dir\\\\wemeetapp_new.exe\\\" -Recurse -Force\", \"startmenu_shortcut -target $(Get-Item \\\"$dir\\\\wemeetapp.exe\\\") -shortcutName \\\"Tencent Meeting\\\"\", \"startmenu_shortcut -target $(Get-Item \\\"$dir\\\\wemeetapp.exe\\\") -shortcutName \\\"腾讯会议\\\"\" ], \"pre_uninstall\": [ \"if (Get-Process -Name \\\"wemeetapp\\\" -Erroraction SilentlyContinue) {Stop-Process -Name \\\"wemeetapp\\\"}\", \"if (Test-Path \\\"$(shortcut_folder)\\\\Tencent Meeting.lnk\\\"){Remove-Item \\\"$(shortcut_folder)\\\\Tencent Meeting.lnk\\\" -Force}\", \"if (Test-Path \\\"$(shortcut_folder)\\\\腾讯会议.lnk\\\"){Remove-Item \\\"$(shortcut_folder)\\\\腾讯会议.lnk\\\" -Force}\" ] } 有些软件是不能直接解压缩的，而是通过 Inno 方式进行安装，这种的话 scoop 也有自带提供支持，可以参考其它软件，等我遇到的时候再补充。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:4:4","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"问题记录 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:5:0","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"GitHub 访问 401 问题 遇上 GitHub API 访问受限导致的 401 问题，可以设置环境变量SCOOP_GH_TOKEN，使用自己的 Access Token 即可。创建 Access Token 的时候不需要指定任何特别的权限，使用默认权限即可。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:5:1","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"应用打开网址无法拉起 Chrome 浏览器 尝试过多种方法但是仍然有不低的概率遇上，最后只能放弃使用 scoop 来维护 Chrome，换成 chrome 默认安装之后问题就不再出现了。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:5:2","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"everything 开机启动无效 这里主要在使用 uTools 调用 everything 搜索的时候，每次开机启动需要重新进行索引，按照 uTools 的说法，如果使用的是安装版并且开机启动的前提下，是不会触发使用内置的绿色版 everything 而导致重新索引的问题的。最后也放弃使用 scoop 维护 everything，而使用官方的安装版本进行安装。不过这个问题也可能通过修改 everything 的配置项能解决。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:5:3","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":["Software"],"content":"hash 校验不一致导致无法安装 有一种可能是更换了安装包但是没有更换版本号，也有可能是计算 hash 的时候遇到了一些bug。在执行 scoop install 的时候只要增加 -s 参数即可跳过 hash 校验。 ","date":"2024-01-17","objectID":"/2024/01/use-scoop-as-windows-package-manager-experience/:5:4","tags":["scoop"],"title":"Windows 包管理器 Scoop的使用经验","uri":"/2024/01/use-scoop-as-windows-package-manager-experience/"},{"categories":null,"content":"对于查看和分析股票的基础数据，在线表格其实是很不错的分析工具，筛选、排序、数据透视图等操作简直太方便了。 Google文档提供了很强的函数GOOGLEFINANCE，能获取比较丰富的股票数据，通过GOOGLEFINANCE(\"SHE:001309\",\"price\")就能获取最新价格，但是不支持上证只支持深证股票，无奈只能放弃。腾讯文档提供了比较基础的STOCK，能获取比较基础的股票数据。那么我们如何才能实现复杂的股票数据处理呢？Google文档提供了API进行相关的数据操作，而富途API也提供了完整的股票数据获取，结合两者，我们就可以实现完整的流程了。 来直接看下效果： 这是现在Google表格的数据内容，只有股票代号，没有其余信息 这是执行脚本后的效果，自动填充了所有内容（这里表格的列是可以动态调整的） 下面简单描述下技术细节： ","date":"2023-04-14","objectID":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/:0:0","tags":["stock"],"title":"使用富途 API 实现 Google 表格的股票数据在线更新","uri":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/"},{"categories":null,"content":"通过Google API读取及更新表格内容 Google官方提供了非常详细的示例，直接参考应该就可以操作了。注意一点，好像是只支持OAuth方式进行操作，这点还是稍有些不方便。仅做了层简单的封装，暴露外部的接口如下： try: sheets = GoogleSheets(token_file) except InvalidCrendentialException as err: DoAuth(token_file) sheets = GoogleSheets(token_file) # 读取单个范围数据 print(sheets.GetValue(spreadsheet_id, 'A2:C3')) # 同时读取多个范围数据 print(sheets.BatchGetValue(spreadsheet_id, ['A2:B4', 'C2:D4'])) # 更新多个范围数据 range_list = ['B3:C4', 'E3:F4'] values_list = [[['x1', 'x2'], ['x3', 'x4']], [['x5', 'x6'], ['x7', 'x8']]] sheets.BatchUpdateValue(spreadsheet_id, range_list, values_list) # 更新单个范围数据 sheets.UpdateValue(spreadsheet_id, 'A15:B16', [['xx', 'yy'], ['zz', 'hh']]) ","date":"2023-04-14","objectID":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/:1:0","tags":["stock"],"title":"使用富途 API 实现 Google 表格的股票数据在线更新","uri":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/"},{"categories":null,"content":"通过富途API读取股票基础行情 这里也制作了一层简单的封装，具体可以参考富途官方的说明。我们需要在机器上先安装FutuOpenD，可以在服务器上安装，并监听0.0.0.0，这样可以在各个客户端直接调用了。 class FutuHelper: def __init__(self, host, port): self.quote_ctx = OpenQuoteContext(host, port) def __del__(self): self.quote_ctx.close() def GetMarketState(self, code_list): \"\"\"获取指定标的的市场状态 获取stock_name(股票名称)、market_state(交易情况) 参考：https://openapi.futunn.com/futu-api-doc/quote/get-market-state.html \"\"\" return self.quote_ctx.get_market_state(code_list) def GetMarketSnapshot(self, code_list): \"\"\"获取快照 获取各类价格信息，包含最新价、开盘、最高、最低、最新、均价、历史高价、历史低价等，以及 财务信息，包含市盈率、总市值、流通市值、资产净值、净利润、每股盈利、股本数量等 参考：https://openapi.futunn.com/futu-api-doc/quote/get-market-snapshot.html \"\"\" return self.quote_ctx.get_market_snapshot(code_list) ","date":"2023-04-14","objectID":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/:2:0","tags":["stock"],"title":"使用富途 API 实现 Google 表格的股票数据在线更新","uri":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/"},{"categories":null,"content":"处理股票行情数据 为了方便表的列名使用中文描述，做一层简单的转换，同时增加一些自定义的字段。比如富途本身不支持涨跌幅，我们可以拿最新价和昨日收盘价计算即可。还有一些用来方便查看的数据，比如高点对比、低点对比等。 处理流程相对比较简单，主要的数据通过get_market_snapshot获取即可。这里扩展的话，我们可以增加一些历史K线数据字段，比如3日最高价、3日均线等等。 ","date":"2023-04-14","objectID":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/:3:0","tags":["stock"],"title":"使用富途 API 实现 Google 表格的股票数据在线更新","uri":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/"},{"categories":null,"content":"扩展下 有这个流程了之后，还可以做更多事情： 同步自选股：从google文档读取自选股列表，通过富途API同步自选股。这样的话可以用Google文档作为源数据进行维护，可惜同花顺没有API进行自选股同步； 批量更新到价提醒：从google文档读取特定股票列表，通过富途API批量增加到价提醒； ","date":"2023-04-14","objectID":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/:4:0","tags":["stock"],"title":"使用富途 API 实现 Google 表格的股票数据在线更新","uri":"/2023/04/futu-update-stock-data-with-futuapi-and-google-sheets/"},{"categories":["AI"],"content":"最近 Stable Diffusion 都大火，小红书上也是各种 AI 美女图，我也来凑一把热闹。 ","date":"2023-03-14","objectID":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/:0:0","tags":["AI"],"title":"使用 Stable Diffusion 生成美女图","uri":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/"},{"categories":["AI"],"content":"安装Stable Diffusion web UI 需要先安装好python 3.10和git（对于程序员的机器来说应该都是必备的了），直接两步执行就好了： 导出git仓库：git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 运行脚本：webui-user.bat，这一步下载pytorch可能耗时较长，耐心等待即可； 执行完成之后，会提示访问http://127.0.0.1:7860/即可体验了； 可以输入一些简单的标签体验下效果，多个标签用,分割，只支持英文；对于不熟悉的标签可以参考网站； 这时候会发现效果没想象的那么好，尤其是生成的“美女”图，可能千奇百怪。 ","date":"2023-03-14","objectID":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/:1:0","tags":["AI"],"title":"使用 Stable Diffusion 生成美女图","uri":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/"},{"categories":["AI"],"content":"使用ChilloutMix模型 在civitai上下载ChilloutMix模型，模型较大，耐心等待； 下载完成后放入目录stable-diffusion-webui\\models\\Stable-diffusion； 重新刷新页面就可以看到左上角可以选择模型了； ","date":"2023-03-14","objectID":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/:2:0","tags":["AI"],"title":"使用 Stable Diffusion 生成美女图","uri":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/"},{"categories":["AI"],"content":"使用Lora插件 在civirtai上下载lora插件； 下载完成后放入目录stable-diffusion-webui\\extensions\\sd-webui-additional-networks\\models\\lora； 切换到Extensions，选择Load From，搜索Kohya-ss Additional Networks，点击Install 切换Settings，选择Reload UI ","date":"2023-03-14","objectID":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/:3:0","tags":["AI"],"title":"使用 Stable Diffusion 生成美女图","uri":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/"},{"categories":["AI"],"content":"开始玩耍 在ChilloutMix中选择你喜欢的图片，比如这张，拷贝右侧的标签信息； 看看生成的效果 仔细看能发现一个比较大的问题，就是手指还是会有各种奇怪的现象 ","date":"2023-03-14","objectID":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/:4:0","tags":["AI"],"title":"使用 Stable Diffusion 生成美女图","uri":"/2023/03/using-stable-diffusion-web-to-generate-ai-girl/"},{"categories":["Software"],"content":"Windows 下一直在使用 7zip 作为唯一的压缩解压缩工具，不过解压缩的手有个一直困扰的问题：如果直接解压缩到当前目录，可能会出现一堆散乱的文件；如果解压缩到同名的目录，可能会导致多一层无用目录。原因就是因为有些压缩文件里面有根目录，而有些又没有。实际上一般会选择第二种方案，毕竟多一层目录结构总好于散乱的文件还要花时间清理。其实要解决这个问题很简单，提供一个所谓的“智能解压缩”就够了，实现起来可能也没几行代码，不知道 7zip 为啥一直没有支持。 今天看到一篇吐槽 bandzip 国内代理不退款的帖子，想着换个能支持“智能解压缩“的工具，参考了下windows 上最好的压缩软件是哪个，推荐最多的依次是 7zip (18 票)、WinRar（16 票）、Bandizip（16 票）、360 压缩（8 票）。对 WinRar 历史上一直没有好感，果断还是选择 Bandzip 了。 直接列举下 Bandzip 的优点： 最重要的一点支持智能压缩，并且可以选择右键一级菜单、二级菜单或者双击直接执行；智能压缩后还支持直接打开压缩后的目录，删除压缩文件 支持右键直接预览文件，这点也很实用，不过我还是把它折叠到了二级菜单里面。 提供了完善的选项设置，比如压缩文件名可以支持自定义，删除压缩文件可以选择是否放回收站，右键是否展示图标 icon，支持配置备份和导入等等； 还有个很重要的点，Bandizip 不属于开源软件，部分功能需要付费才能使用。不过好在不是坑爹的订阅制，一次性付费 30 美元或 199 人民币就可以解锁专业版功能，包括广告去除、包内图片预览、压缩包修复等，还有密码器管理、恶意文件扫描等。后面两项功能其实算是和压缩工具不那么搭边，也可以认为作者比较善良，附赠了一些能力吧哈哈，只是我目前还没需求购买专业版，用一段时间再看看吧。 顺便研究了付费的这几个功能点 密码管理器：密码记录在注册表，如果设置了主密码那么存放的就是加密后的串，如果忘记了主密码重置的时候只能清空所有密码信息。这项功能其实和所谓的密码管理器差距还挺大的，注册表毕竟也不是那么可靠，官网也说明了不要完全依赖密码管理器。 压缩包内恶意软件扫描：开始我以为它自己做了一套安全扫描工具，还在想代价会不会太大了。看了文档才知道，windows 提供了反恶意软件扫描接口 (AMSI) 的通用接口标准，可以将杀毒软件的能力继承在其他产品中。不仅仅是自带的Windows Defender支持AMSI，还有Kapersky、MCAfee等等，不过看到描述的腾讯电脑管家不支持AMSI，还是有点感叹，国内的产品太没有开放意识了。 密码修复：其实就是提供了一个暴力破解的方式，官网也很友好的给出了预估时间 压缩包内图片预览：这个对于有需求的人来说还是挺实用性的，我个人好像没啥需求； 压缩包修复：没有太明确的说明，我猜测有可能只是基于文件标准格式的简单处理，毕竟也不会保证修复的成功率； ","date":"2023-03-02","objectID":"/2023/03/bandizip-as-zip-app-on-windows/:0:0","tags":["bandizip"],"title":"Windows 下使用 Bandizip 替换 7zip","uri":"/2023/03/bandizip-as-zip-app-on-windows/"},{"categories":null,"content":"从腾讯云告警聊起 自从将腾讯云的 CVM 流量计费模式从”按宽带计费“调整成”按流量计费“之后，总担心突发的DDOS攻击或者随便写个脚本都会导致我的流量费用短时间暴增。目前的带宽上限是 10Mbps，如果被人攻击了 7 天，那么总费用就需要10*86400*7/8=756元。那如果被攻击了 3 个月没发现呢？我账户里面没有那么多钱啊，应该早被停止服务了，那么我应该也就发现了。 为了避免损失不断扩大，我们需要有完备的监控体系和通知体系了，幸好腾讯云提供的监控体系还是比较完整的。不管是传统的的邮件、短信、电话（收费）外，还是企业微信、钉钉、飞书、slack（这些算是腾讯适配他们的协议了），此外还能支持微信服务号（算是腾讯内部的特殊权利了），以及自定义回调服务。 对比起来群晖的通知体系就比较弱了，支持电子邮件、短信（第三方）、群晖管家的推送和自定义回调服务。而对网站的一些监控是只能依赖 pushover 的。 以后可能还有各种告警通知，在想这里能不能统一管理，并且可以比较方便的扩展。 如果再往外扩展一步的话，其实不止是告警，也可能是各种其他事件。哈哈，这就有点 IFTTT 的味道了。 ","date":"2023-02-14","objectID":"/2023/02/from-monitor-to-ifttt-intro/:1:0","tags":["ifttt"],"title":"从告警聊到 IFTTT","uri":"/2023/02/from-monitor-to-ifttt-intro/"},{"categories":null,"content":"IFTTT 现状 想到这里，我去搜索了一遍国内IFTTT的现状，结果是惨不忍睹啊。看看这些名字尽管都很山寨，但是怎么就一个也不剩了呢。这些文章大部分还是在 2015 年的，最近几年甚至都没什么人聊起IFTTT了。 如果是 如果云 如果就 假如就 一旦就 与此同时，我也去搜了国外的IFTTT发展，发现Integromat的也已经玩出了新花样。看看下面的流程图，收到邮件后，表格中插入一行，然后对附件进行处理，将图片发表到 Facebook，将文档打包上传到 dropbox。 不得不说，这真的很酷，有没有一点像 devops 流行的流水线逻辑。但其实更羡慕的是国外软件开放的思路，几乎大的产品都能提供开放 API，不管是 google 系列的 gmail、google docs，还是 facebook、twitter、instagram、dropbox、evernote、notion 等等。不管是十几年前的产品，还是这几年新出的产品，都会将 API 开放作为重要的功能之一。 反观国内的话，手 Q 和微信带来的 OAuth 流行（每个产品都相当入口哈哈），这几年随着钉钉、企业微信、飞书等协同办公平台的兴起，整个现状比之前是好了太多了。尽管目前相对国外而言还是挺大，不过还是可以期待几年之后，互联网产品能真正从底子里把开放作为基础功能（不做开放功能就别上线哈哈！）。 ","date":"2023-02-14","objectID":"/2023/02/from-monitor-to-ifttt-intro/:2:0","tags":["ifttt"],"title":"从告警聊到 IFTTT","uri":"/2023/02/from-monitor-to-ifttt-intro/"},{"categories":null,"content":"集简云实操 IFTTT 说回国内IFTTT的现状，搜索了下一圈发现集简云算是继承了IFTTT的思想，看下他的界面，从”选择触发动作“到”执行这个动作“就是它最基本的设计。 并且有点意外的是支持的应用还挺多的，号称有 493 个应用。 当然受限于应用本身开放的能力，有些功能是实现不了的。举例来说，小红书就只能支持”订单“相关的出发条件，而不能支持”关注的人“发表文章等条件。 但是实测的时候发现很多应用各种报错、各种无法使用，包括头条、抖音、曹操叫车等等之类的，本来还想着实现个好玩的流程实验下的。 回到开始的问题，我们是否可以依赖集简云来实现消息管理中心呢，先拿腾讯云告警通知实验下，整个流程还算是比较顺利。 使用 webhook 作为触发条件： 点击下一步后，会生成一个 webhook 的 URL 地址，将该 url 地址填写到腾讯云告警的回调地址中 点击下一步后可以获取样本数据，这时候可以先在腾讯云上配置一个容易触发的告警事件，比如 CPU\u003e1%之类的，触发之后可以在这里看到样本数据内容，主要是方便后续选择相应字段。这里没有关于回包格式更多清晰的描述，不过至少标准的 json 是支持的。 终于可以到第二步的执行事件了，使用 push 作为关键字试了下，只找到一个pushplus，那就用用看吧。 账号这里，参考说明操作就行了，需要关注公众号然后在菜单中去选择相关 token 信息，如果需要使用客服消息的时候则需要有手动操作行为，并且只有 48 小时有效期，否则使用模板消息下发（有总次数限制，之前微信还说要下架后面不了了之了）。不过这也算是微信服务号消息发送的统一解决方案了。 消息标题和内容操作还是比较傻瓜化的，直接选择相应字段作为变量就可以了。 保存之后可以测试下效果，发现在微信公众号里面可以收到消息了。 整体用下来，感觉还是不够专业啊，变量设置尽管够”傻瓜化“，但是没看到有更高级的用法。比如需要有高级的变量选择器，类似 XML 的 XPATH 选择器；针对回包内的字段有不同的分支处理；甚至是支持简单的脚本逻辑等；至少是距离我的想像有比较大的差距，另外界面设计上感觉也不太专业。 最后发现每个月的免费调用次数只有 500 次（真的有点少），收费价格貌似还挺高的，当然我不可能成为付费用户了。不过作为国内可能仅有的类IFTTT产品，有需要的还是可以多支持支持。 后面我估计还是会使用IFTTT来进行相关处理，或者自己单独搞一套似乎也不太难，以后再说吧！ ","date":"2023-02-14","objectID":"/2023/02/from-monitor-to-ifttt-intro/:3:0","tags":["ifttt"],"title":"从告警聊到 IFTTT","uri":"/2023/02/from-monitor-to-ifttt-intro/"},{"categories":null,"content":"对于输入法来说，皮肤可以说是非常重要，我们设置一款感觉舒适的，对于打字体验来说能提升不少。毕竟大家不是设计师，我们可以自己盗取成熟的输入法的皮肤效果就好了。这里我们参考的是微软拼音输入法，毕竟作为 windows 系统自带的，微软的设计师水准还是值得信赖的。 ","date":"2023-02-07","objectID":"/2023/02/simulate-microsoft-input-method-skin-in-rime/:0:0","tags":["rime","小狼毫"],"title":"小狼毫100%模仿微软输入法的皮肤","uri":"/2023/02/simulate-microsoft-input-method-skin-in-rime/"},{"categories":null,"content":"效果对比 先看下效果，这个是 Windows 系统自带的微软拼音输入法 这个是小狼毫模拟的效果，应该做到了 99%的相似度吧。 ","date":"2023-02-07","objectID":"/2023/02/simulate-microsoft-input-method-skin-in-rime/:1:0","tags":["rime","小狼毫"],"title":"小狼毫100%模仿微软输入法的皮肤","uri":"/2023/02/simulate-microsoft-input-method-skin-in-rime/"},{"categories":null,"content":"皮肤颜色设置 官网给了比较清晰的颜色样式配置说明，另外也提供了一个方便的在线工具用来生成配置。我们用取色工具获取微软拼音输入法的相关颜色填充即可（可以用系统自带的画图工具）。 在配置文件weasel.custom.yaml里面将相关内容填写进入即可。 ","date":"2023-02-07","objectID":"/2023/02/simulate-microsoft-input-method-skin-in-rime/:2:0","tags":["rime","小狼毫"],"title":"小狼毫100%模仿微软输入法的皮肤","uri":"/2023/02/simulate-microsoft-input-method-skin-in-rime/"},{"categories":null,"content":"样式设置 这块可能稍微复杂一些，这里不做具体介绍了。结合皮肤设置的内容，在weasel.custom.yaml的内容现在是这样： patch: preset_color_schemes: microsoft_sim: name: 仿微软输入法 author: plutotree back_color: 0xF4F4F4 border_color: 0xDCDCDC text_color: 0x000000 hilited_text_color: 0xF4F4F4 hilited_back_color: 0xFFD8A6 hilited_candidate_text_color: 0x000000 hilited_candidate_back_color: 0xFFD8A6 candidate_text_color: 0x000000 comment_text_color: 0x888888 style: color_scheme: microsoft_sim label_format: \"%s\" font_face: \"微软雅黑\" font_point: 14 horizontal: true inline_preedit: true layout: min_width: 160 min_height: 0 border_width: 1 border_height: 1 margin_x: 12 margin_y: 12 spacing: 10 candidate_spacing: 24 hilite_spacing: 8 hilite_padding: 12 round_corner: 0 此外，候选词的个数设置是在文件default.custom.yaml，如果有需要修改成和微软拼音输入法一样的 7 个，可以这样填写。 patch: menu: page_size: 7 需要注意的一点是patch字段内容要和原来的合并，不能新增一个patch字段。 ","date":"2023-02-07","objectID":"/2023/02/simulate-microsoft-input-method-skin-in-rime/:3:0","tags":["rime","小狼毫"],"title":"小狼毫100%模仿微软输入法的皮肤","uri":"/2023/02/simulate-microsoft-input-method-skin-in-rime/"},{"categories":null,"content":"问题描述 前段时间证书更新后，发现在 linux 服务器上使用 curl 命令访问会提示curl: (60) Peer's Certificate issuer is not recognized. [root@centos]# curl \"https://www.plutotree.cn\" curl: (60) Peer's Certificate issuer is not recognized. More details here: http://curl.haxx.se/docs/sslcerts.html curl performs SSL certificate verification by default, using a \"bundle\" of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn't adequate, you can specify an alternate file using the --cacert option. If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL). If you'd like to turn off curl's verification of the certificate, use the -k (or --insecure) option. 增加--verbose参数可以得到更详细的信息 * Initializing NSS with certpath: sql:/etc/pki/nssdb * CAfile: /etc/pki/tls/certs/ca-bundle.crt CApath: none * Server certificate: * subject: CN=plutotree.cn * start date: Feb 01 09:09:40 2023 GMT * expire date: May 02 09:09:39 2023 GMT * common name: plutotree.cn * issuer: CN=R3,O=Let's Encrypt,C=US * NSS error -8179 (SEC_ERROR_UNKNOWN_ISSUER) * Peer's Certificate issuer is not recognized. * Closing connection 0 使用浏览器访问的时候是正常的，不管是 chrome 还是 Safari。 ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:1:0","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"问题定位及解决 ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:2:0","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"尝试更新根证书无效 首先怀疑的是根证书问题，搜索之后最常见的解决方案是更新根证书，在centos下执行下述命令： yum install ca-certificates update-ca-trust force-enable update-ca-trust extract ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:2:1","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"尝试手动更新证书 另外的思路就是手动将网站证书添加，但这个终归不是一个好办法，简单尝试了（发现仍然无效）下就放弃了（估计是哪一步操作不对）。 ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:2:2","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"从 zerossl 更换回 Let’s Encrypt 这次使用acme.sh更新证书的时候，是有提示默认服务切换至 zerossl，怀疑是不是 zerossl 颁发的证书导致无法正确识别，所以切换回去使用 Let’s Encrypt 了，结果当然是仍然无效。 ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:2:3","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"发现一段重要说明 在 acme.sh 发现一段重要说明： Nginx 的配置ssl_certificate使用/etc/nginx/ssl/fullchain.cer，而非/etc/nginx/ssl/\u003cdomain\u003e.cer ，否则SSL Labs的测试会报Chain issues Incomplete错误。 立刻尝试手动拷贝文件并且修改了下 nginx 配置，问题直接就解决了。 之前的证书安装命令压根就没有指定--fullchain-file，而只是指定了--key-file和--cert-file，而在 nginx 下--cert-file是不需要的，--fullchain-file确实必须的。之前看文档的时候就错看了这一点结果悲剧了。 acme.sh --install-cert -d plutotree.cn --cert-file /etc/nginx/conf.d/plutotree.cn.cer --key-file /etc/nginx/conf.d/plutotree.cn.key --fullchain-file /etc/nginx/conf.d/fullchain.cer --reloadcmd \"systemctl force-reload nginx\" ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:2:4","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"总结教训 搜索引擎不是万能的！还是要先多看看文档！ ","date":"2023-02-01","objectID":"/2023/02/fix-curl-certificate-problem/:3:0","tags":["ssl"],"title":"记录一个 curl 访问的 https 证书问题","uri":"/2023/02/fix-curl-certificate-problem/"},{"categories":null,"content":"背景 之前有在用 pushbullet 作为消息推送服务，以及偶尔将它当做多平台的分享工具。前几天发现我的 bitwarden 网站突然不能正常使用了，想着还是需要接入页面的自动监控及消息推送，这时才发现 pushbullet 竟然不支持 iOS（前几个月换回了 iPhone 作为主力机），这不是推我离开 pushbullet 么。大致搜索了下，除了 pushover 似乎也没有太多好的选择了。 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:1:0","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"pushbullet 和 pushover 对比 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:2:0","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"支持的平台 Pushbullet Pushover iOS - 支持 Android 支持 支持 浏览器 支持 支持 Windows 支持 - ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:2:1","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"费用对比 Pushover： 提供 30 天的试用期，后续使用需要付费； 个人用户 5 美元一个平台（一次性收费），不限制设备数量； Pushbullet 每月提供 500 条免费消息，超出则需要升级 Pro 版本； 订阅制，一个月 4.99 美元（年付折合 3.33 美元/月）； ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:2:2","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"其他说明 Pushove 提供了较为丰富的 push 相关选项，包括自定义图标、自定义声音、url 跳转，以及优先级别的设置等； Pushbullet 提供了基于 channel 维度的推送，并且可以开放给其他用户订阅；Pushbullet 提供了发送文件、设备间共享信息、短信复制等能力； ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:2:3","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"总结说明 Pushover 是一个比较纯粹的消息推送服务，它的能力主要在于此也仅限于此。如果你需要发送消息提醒到手机，那应该算是最佳选择了； Pushbullet 竟然不支持 iOS，这点其实还是有点意外的，原生 windows 可以不支持，但是怎么能不支持 iPhone 呢； Pushbullet 除了发送消息外，各设备之间的消息分享非常有用，有段时间我都把它当做手机（安卓）和电脑（Mac）之间进行文字和文件传递的首选产品。当然如果使用的是 iPhone 和 mac，那必然是 AirDrop 的填下了。 Pushbullet 的 Channel 和订阅能力也算是提供了一个社区化的能力，可以运营自己的 channel，不断增加粉丝，然后可以发送广告哈。 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:2:4","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"国内的同类软件 参考知乎上的帖子【国内有没有类似于 Pushover,PushBullet 等消息推送 app】的评论相关信息，调研里面的一些产品。 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:3:0","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"server 酱 第一版本依赖于微信消息，第二版本可以支持多通道，推荐使用企业微信和pushdeer。pushover 除了有完善的消息推送能力外，还能支持自建服务器。目前在运营中，并且发展势头较好，开始做自己的推送生态，下面是官网拷贝的。 Server 酱 Turbo：支持企业微信、微信服务号、钉钉、飞书群机器人等多通道的在线服务，无需搭建直接使用，每天有免费额度 Wecom 酱：通过企业微信推送消息到微信的消息推送函数和在线服务方案，开源免费，可自己搭建。支持多语言。 PushDeer：可自行搭建的、无需安装 APP 的开源推送方案。同时也提供安装 APP 的降级方案给低版本/没有快应用的系统。支持作为 Server 酱的通道进行推送，所有支持 Server 酱的软件和插件都能直接整合 PushDeer。 免费用户一天只能发送 5 条消息，并且仅显示标题（基本上不太有可用性），收费价格每个月 8 元或者年付 39 元（折合 3.5 元/月）。不过能力和规划看着还是不错的，如果有时间的话我会深度体验并且对比下 pushdeer 和 pushover 的。 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:3:1","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"喵提醒 之前推荐的是基于微信公众号消息回复，需要用户 48 小时内主动发送消息，我认为是没啥实用性的。模板消息可以一定程度上解决这个问题，不过微信模板前端时间也一直在传要下线呢。另外还支持短信、电话提醒（当然是收费的），我看目前还新支持了安卓 app 和 iMessage 消息提醒。具体没有详细了解，不过这网站页面做的真的是丑，让人不得不怀疑它能做得多好。 server 饭 它的介绍是“服务器给微信发通知消息 或用微信控制你的服务器”，从这段话中也可以看出其实定位还是有差异的，它的出发点应该是通过微信控制服务器，所以服务器上是必须安装有 agent 的，这里也不做详细介绍 了。 ","date":"2023-01-17","objectID":"/2023/01/using-pushover-as-push-channel/:3:2","tags":["pushover","pushbullet"],"title":"从 pushbullet 切换到 pushover 作为消息通知工具","uri":"/2023/01/using-pushover-as-push-channel/"},{"categories":null,"content":"R 基础实战 安装比较简单，从官网下载后执行，可以只选择 x64； 使用R Gui执行 R 命令： 运行R Gui 尝试执行命令： print('hello world!') sqrt(2) [1] 1.414214 \u003e plot(1:10,sqrt(1:10)) 看下执行效果： 使用命令行执行： 设置环境变量，将C:\\Program Files\\R\\R-4.1.2\\bin\\x64添加到PATH中； 命令行指定语句 执行rscript.exe -e \"sqrt(1:10)\"，可以看到命令行能直接输出 执行rscript.exe -e \"plot(1:10,sqrt(1:10))\"，这时候看不到窗口输出，在当面目录会生成Rplots.pdf文件； 执行文件 执行rscript.exe -f \"demo.r\" 使用命令行执行指定文件： 使用任意编辑器创建文件demo.r，里面内容如下 print(\"hello world!\") sqrt(1:10) 执行rscript.exe \"demo.r\" ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:1:0","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"R markdown 实战 ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:2:0","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"安装 Rmarkdown 启动R gui，然后执行语句install.packages(\"rmarkdown\")，执行之后会让选择下载节点； ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:2:1","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"编写 Rmarkdown 文件 使用任意编辑器创建文件demo.rmd，里面内容如下，其实就是 markdown 文件内嵌了 r 语句，这也是 R markdown 的由来 --- title: \"Rmarkdown demo\" output: html_document --- ## 绘图示例 ### 函数曲线图 ```{r} curve(sin(x), 0, 2*pi) ``` ### 条形图 ```{r} barplot(c(\"男生\"=48,\"女生\"=38), main=\"男女生人数\") ``` ### 散点图 ```{r} plot(1:100, sqrt(1:100)) ``` ## 汇总统计 ```{r} data \u003c- read.csv(\"taxsamp.csv\") knitr::kable(table(data[['征收方式']])) knitr::kable((table(data[['征收方式']], data[['申报渠道']]))) summary(data[['营业额']]) ``` ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:2:2","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"编译 Rmarkdown 文件 在命令行下执行语句：Rscript.exe -e \"library('rmarkdown');render('demo.rmd')\"，可以看到有一段编译过程，中间生成了 demo.knit.md，最后生成了 demo.html ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:2:3","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"查看 html 文件 查看生成的demo.html，效果如下： ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:2:4","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"推荐教程 R 语言教程 by 李东风 庄闪闪的 R 语言手册 bookdown: Authoring Books and Technical Documents with R Markdown ","date":"2022-02-20","objectID":"/2022/02/using-rmarkdown-on-windows/:3:0","tags":["rmarkdown"],"title":"Windows 下 R mardown 入门实战","uri":"/2022/02/using-rmarkdown-on-windows/"},{"categories":null,"content":"为啥需要更换输入法？ 互联网上的隐私泄漏问题一直是讨论的热点，比如姓名、电话、职业、学校等，更进一步还有家庭住址、家庭成员等。那么有没有想过，这么多互联网产品中，拥有你最多隐私的数据产品是什么？很多人会选择微信、微博、抖音等产品，因为它们有我们的关系链、兴趣爱好、LBS 信息、作息习惯等等。这些都没有问题，但是有没有想过我们常用的输入法所拥有的信息甚至比这些产品还要多。而目前大部分输入法都会将输入词传输到云端进行联想提示。想象下，如果将你这么多年的输入词完整分析一遍，能得到多少你个人信息，以及社交信息，甚至分析你的个人性格都不是啥问题。 ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:1:0","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"选择一款开源的输入法 RIME算是最好、最强大的开源输入法，甚至没有之一。它在一个统一的后端服务基础上，利用不同的前端来支持 Windows、MacOS、Android、Linux，实现跨操作系统和跨设备。在 Windows 下叫“小狼毫” (Weasel)，在 Mac 下是“鼠须管” (Squirrel)，在 Linux 下叫“中州韵” (ibus)。此外还有 Android 版本。这里只介绍 windows 和 mac 上的安装和使用方式，而 iOS 上输入法如果不打开联网权限安全和隐私保护是可靠的。 ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:2:0","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"安装及基础使用 ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:3:0","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"Windows 下小狼毫的安装 在官网下载小狼毫； 安裝完成需要选择输入方案，可以只保留朙月输入法，在皮肤选择中可以选择自己喜欢的样式 这时候可以正常输入，但是展示的是繁体字，按 F4 选择简体； 默认的是纵向选择候选词，可能不符合一般的使用习惯，可以打开目录%APPDATA%\\Rime中下的文件weasel.custom.yaml（如果不存在的话则新建即可），增加下述内容： patch: style: horizontal: true 在菜单中选择“重新部署”后，就可以看到效果了； ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:3:1","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"Mac 下鼠须管的安装 安装 RIME，安装过程需要输入密码 brew install squirrel --cask 添加输入法，在输入法管理中添加“鼠须管”输入法 这时候就可以正常输入了，不过出来的是繁体字，需要调整为简体字。在输入状态下，按 F4 可以选择切换为简体。 默认的是纵向选择候选词，可能不符合一般的使用习惯，打开目录~/Library/Rime下的文件squirrel.custom.yaml（如果不存在则新建），内容如下： patch: style: horizontal: true 选择重新部署后，可以实现横向选择了 ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:3:2","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"Rime的相关参考资料 四叶草拼音输入方案，做最好用的基于rime开源的简体拼音输入方案！ Rime 配置：雾凇拼音 | 长期维护的简体词库 Rime Squirrel 鼠须管配置文件（朙月拼音、小鹤双拼、自然码双拼） Rime（中州韵）全拼与双拼的自用配置方案 ","date":"2021-12-15","objectID":"/2021/12/using-rime-on-pc/:4:0","tags":["rime"],"title":"使用RIME输入法","uri":"/2021/12/using-rime-on-pc/"},{"categories":null,"content":"使用ctexbook的一个最简单的模板 标题页无页码； 目录页无页码； 正文页页码重新计数； 设置好字体后可以直接在overleaf上面运行； 代码如下： \\documentclass{ctexbook} % 设置页边距 \\usepackage[margin=3.18cm,a4paper]{geometry} % 在OverLeaf上可以使用指定字体 % \\setmainfont{Caladea} \\pagestyle{headings} \\title{三国演义} \\author{罗贯中} \\date{} \\begin{document} % 标题页不需要页码 \\maketitle \\thispagestyle{empty} % 目录页不需要页码 \\tableofcontents \\thispagestyle{empty} % 页码重新计数 \\setcounter{page}{0} \\chapter{宴桃园豪杰三结义\\ 斩黄巾英雄首立功} \\noindent 滚滚长江东逝水，浪花淘尽英雄。\\\\ 是非成败转头空。\\\\ 青山依旧在，几度夕阳红。\\\\ 白发渔樵江渚上，惯看秋月春风。\\\\ 一壶浊酒喜相逢。\\\\ 古今多少事，都付笑谈中。\\\\ ------调寄《临江仙》 话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉。汉朝自高祖斩白蛇而起义，一统天下，后来光武中兴，传至献帝，遂分为三国。推其致乱之由，殆始于桓、灵二帝。桓帝禁锢善类，崇信宦官。及桓帝崩，灵帝即位，大将军窦武、太傅陈蕃共相辅佐。时有宦官曹节等弄权，窦武、陈蕃谋诛之，机事不密，反为所害，中涓自此愈横。 \\chapter{张翼德怒鞭督邮\\ 何国舅谋诛宦竖} 且说董卓字仲颖，陇西临洮人也，官拜河东太守，自来骄傲。当日怠慢了玄德，张飞性发，便欲杀之。 \\end{document} ","date":"2021-11-22","objectID":"/2021/11/latex-chinese-book-simple-template/:0:0","tags":["latex"],"title":"latex中文书籍模板","uri":"/2021/11/latex-chinese-book-simple-template/"},{"categories":null,"content":"一直没想明白 evernote 国际版为啥一直不支持多级标题，这几乎是一个基础特性的缺失。网上的资料大多是用autohotkey来实现的，基本处理函数如下： 这里没有好的设置行间距的方式，样式比较丑，今天发现有直接对剪切板操作的脚本，转而一想我们可以通过直接插入\u003ch1\u003e\u003c/h1\u003e等 html 标签的方式来实现标题的设置，因为 evernote 本身是支持这些标签的。 这里直接给 AutoHotkey 的代码： 有一点的问题在于ClipWait看着并不生效，没有后续的Sleep是会有概率粘贴失败的。所以这个方案也并不完美，只是勉强可用，需要的可以点击下载。 实现效果就是这样子（这里的序号手动加的）： ","date":"2021-11-03","objectID":"/2021/11/use-autohotkey-to-implement-evernote-multi-level-title/:0:0","tags":["autohotkey","evernote"],"title":"使用autohotkey实现evernote的多级标题","uri":"/2021/11/use-autohotkey-to-implement-evernote-multi-level-title/"},{"categories":null,"content":"前言 Markdown 已然成为事实上的技术文档编写标准，作为 markdown 编辑器，typora 也收到越来越多人的推荐和喜爱。在 markdown 中我们经常需要插入图片，而 markdown 只是普通文本文件，因此图片只能作为外部链接而存在。这里的链接可以使用本地的相对路径，也可以使用网络 url。当使用网络 url 的时候，我们需要一个地方去维护和存储图片，这就是我们所谓的“图床”。 而我之前一直没有考虑使用图床，图片都是和 markdown 文件一起在 git 里面维护，主要的考虑点有： markdown 文件以及图片是作为一个整体，可以理解成是一个项目，那么项目内容本身就是密不可分的； 图片的访问权限可以跟随 markdown 文件，需要时可以有统一的访问鉴权策略； 方便管理一篇文章的所有图片，对于无用的图片可以直接删除； 在使用过程中遇到了越来越多的不便之处： github 网站在国内访问速度较慢，文字影响不大，大量的图片下载耗时很影响体验； 不方便直接分享给他人 markdown 文件，需要导出 pdf 或者打包进行分享； 在 github 仓库中，大量的图片也影响了 git 仓库的导出速度； 本地存储图片时，图片存储路径在不同场景有差异，不方便统一管理； 不能方便地进行图片的动态缩放； 权衡之后决定还是决定拥抱“图床”。typora 自带支持 iPic、uPic、PicGo 等图片上传工具，我选择国人开发的 PicGo。另外因为一直在用腾讯云服务器，自然选择了腾讯云 cos 作为图床的云存储。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:1:0","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"腾讯云 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:2:0","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"对象存储 在对象存储控制台创建一个存储桶，选择所属地域，填写桶名称，访问权限选择“公有读私有写” 点击桶名称进入管理页面，在左侧“域名与传输管理”中打开默认 CDN 加速域名，这里需要理解下 CDN 和源站的概念 回到文件列表页，可以在页面进行上传测试，点击“详情”可以查看文件的具体信息，这里对象有两个访问地址，一个是源站域名，一个是加速域名，我们一般都会选择加速域名。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:2:1","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"数据万象 使用图床还有一点很重要的作用是能实现动态的图片处理，简单的比如缩放、裁剪，复杂的比如高斯模糊、水印等等，这里需要用到腾讯的数据万象。在数据万象的存储通管理中，选择绑定存储桶即可。 点击存储通名称进入管理页面，发现这里也有个域名管理，通过这个域名访问才会支持图片的在线处理功能，这个域名本身也是支持 cdn 加速的，我们会统一采用这个域名来提供用户访问。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:2:2","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"访问授权 在腾讯云控制台的访问管理中新建用户，可以直接使用\"快速创建\"。这里访问方式修改为“编程访问”，用户权限清空，可接受消息类型清空，用户名称可以用比较清晰明了的，比如picgo-upload。创建成功之后能看到子账号的账号 ID，还有 SecretId 和 SecretKey，把这些信息记录下来，我们后续需要用到。 回到对象存储控制台，选择“授权管理”，勾选存储桶后修改“用户权限”，增加子账号的权限，权限内容可以勾选数据读取和数据写入。 到此，腾讯云上的工作做完了。其实有一点没有谈的是费用问题，这个的话还是有必要了解的，只是这篇文章略过了。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:2:3","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"Picgo PicGo是一款开源跨平台的图片上传工具，能方便地上传至各种图床和云存储服务器上。可以使用带图片 GUI 的应用，也可以直接使用其核心部分基于命令行的PicGo-Core。我推荐直接使用 PicGo-Core，再加上插件能力足够满足我们的需求了。 # 如果没有npm的话需要先安装 # brew install npm # 安装picgo npm install picgo -g # 安装picgo插件 picgo install autocopy picgo install rename-file 安装完 picgo 和插件之后需要进行相关配置，同样有两种方式，一种是基于命令行的交互输入，而另一种是推荐的直接修改配置文件。配置文件在 Windows 下路径为 %HOMEPATH%\\.picgo\\config.json，Mac 下路径为~/.picgo/config.json。 { \"picBed\": { \"current\": \"tcyun\", \"tcyun\": { \"secretId\": \"子账号的SecretId\", \"secretKey\": \"子账号的SecretKey\", \"bucket\": \"Bucket名称\", \"appId\": \"\", \"area\": \"COS区域，类似ap-shanghai\", \"path\": \"\", \"customUrl\": \"数据万象url\", \"version\": \"v5\" }, \"uploader\": \"tcyun\", \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-rename-file\": true, \"picgo-plugin-autocopy\": true }, \"picgo-plugin-rename-file\": { \"format\": \"pic/{y}/{m}/{d}/{rand:6}\" } } 根据上面的注释进行字段的编辑，重命名插件的具体参数可以参考这里。配置完成之后可以通过执行picgo upload xxx.png来验证图片上传及插件配置是否生效。这里 xxx.png 可以支持本地也可以支持网络的 url。如果上传成功之后能看到完整的 url，同时也会将 url 写入剪切板，可以直接在浏览器中进行访问验证。 比如这个地址https://pic-1251468582.file.myqcloud.com/pic/2021/11/03/80da56.png，，可以查看其链接规则是符合 rename-file 插件的配置的。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:3:0","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"Typora 打开偏好设置，按需要勾选之后点击“验证图片上传选项”确认上传是否正常。 这里要注意下 mac 系统的PicGo-Core选项并不可用，需要选择Custom Commeand，手动输入命令。另外命令还需要输入完整地址（我尝试了三遍才知道）。我配置的命令内容如下： /opt/homebrew/bin/node /opt/homebrew/bin/picgo upload 好了，到这里就可以在文章中很方便的插入图片了。使用过程中，可以发现本地图片转化为网络图片是需要一些时间，在上传成功之后才会替换掉本地 url。如果在中途不小心修改或者删除了相关内容，会导致后续替换 url 失败。好在我们是用了 autocopy 的插件，正确地址已经写入剪切板了，只要 ctrl+v 就可以了啦。 ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:4:0","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":"将历史文章中的本地图片批量上传 不想旧文章使用本地图片，而新文章才使用网络图片，这些批量化的工作当然得交给程序。用 node 或许是比较理想的方式，可以直接以 API 形式调用 picgo。但这是在我用 python 写到最后才想起的点。不多说，直接给代码，直接保存运行就好了： import os import re import pyperclip def Upload(img): # 使用picgo上传，需要安装插件autocopy pyperclip.copy(\"\") ret = os.system('picgo upload ./{}'.format(img)) if ret != 0: print('图片[{}]上传失败'.format(img)) return img new_img = pyperclip.paste().rstrip('\\n') if not new_img: print('图片[{}]似乎上传失败'.format(img)) return img print('图片[{}]上传成功 -\u003e[{}]'.format(img, new_img)) return new_img def Process(root, file): content = '' print('process file:{}/{}'.format(root, file)) inf = open('{}/{}'.format(root, file), 'r') for line in inf.readlines(): result = re.finditer('!\\[([^]]*)\\]\\(([^)]*)\\)', line) update = False new_line = '' last_pos = 0 for r in result: img = r.group(2) if not (img.startswith('http://') or img.startswith('https://')): update = True new_line += line[last_pos : r.start(2)] last_pos = r.end(2) new_line += Upload(img) new_line += line[last_pos:] if update: content += new_line else: content += line inf.close() outf = open('{}/{}'.format(root, file), 'w') outf.write(content) outf.close() if __name__ == '__main__': for root, dirs, files in os.walk('./_posts/'): for file in files: if file.endswith(\".md\") or file.endswith(\".markdown\"): Process(root, file) ","date":"2021-11-02","objectID":"/2021/11/using-picgo-as-image-uploader-bed/:5:0","tags":["picgo","markdown","cos","typora"],"title":"markdown图床实践：Typora+PicGo-core+腾讯云cos","uri":"/2021/11/using-picgo-as-image-uploader-bed/"},{"categories":null,"content":" 最近发现无法展示评论，提示找不到 AV 相关的定义，移除了av-min.js，以及AV的字段定义，似乎是新版本改了实现，会在内部引用av-min.js。 博客怎么能少了评论系统，但是一直没有找到满意的，各种国内被禁的，缺乏更新维护的，做得太复杂的等等之类的。今天看到一个感觉还不错的评论系统Valine，一款快速、简洁且高效的无后端评论系统，存储基于 leancloud。作者的博客提供了一个 jekyll 的示例，直接引入。 先参考这里的说明，注册 Leancloud 并创建新的应用，顺便提一下，现在监管严格，需要进行实名注册，最后还要支付宝扫描验证。 接着直接修改 jekyll 的内容即可（下面的内容照抄作者博客，也可以按自己习惯定义变量） 修改default.html，在 footer.html 前面增加下面这段内容 {% if site.data.social.valine_comment.enable and page.comments == true %} \u003cdiv id=\"comments\"\u003e\u003c/div\u003e {% endif %} {% include scripts.html %} 修改_includes/head.html，在合适的地方增加下面这段内容 \u003c!-- Valine Comment --\u003e {% if site.data.social.valine_comment.enable and page.comments == true %} \u003cscript src=\"//unpkg.com/valine/dist/Valine.min.js\"\u003e\u003c/script\u003e {% endif %} 在_includes下面增加新文件valine_comments.html \u003cscript\u003e new Valine({ el: \"#comments\", app_id: \"你的Leacloud Appid\", app_key: \"你的Leancloud Appkey\", placeholder: \"{{ site.data.social.valine_comment.placeholder }}\", }); \u003c/script\u003e 在_includes下面增加新文件scripts.html（需要手动在{后面及}前面增加%） { if page.comments }{ include valine_comments.html }{ endif } 在_data下面增加新文件social.yml valine_comment: enable: true leancloud_appid: 你的Leancloud Appid leancloud_appkey: 你的Leancloud appkey placeholder: just go go 在你的文章头增加comments: true 另外还看到一个基于 valine 的评论系统，叫做waline，功能很齐全，有空可以再研究下。 ","date":"2021-09-06","objectID":"/2021/09/add-valine-comment-system-in-jekyll/:0:0","tags":["jekyll","valine"],"title":"在jekyll中使用valine评论系统","uri":"/2021/09/add-valine-comment-system-in-jekyll/"},{"categories":null,"content":"网上有大量文章说明如何在 github pages 上面使用 jekyll，这里仅说明下大致流程 导出 git 本地编辑 markdown 本地启动 jekyll，验证文章效果 git 提交 网页生效 选择合适的 jekyll 模版，也可以直接使用我的网站（记得删除_posts 和 raw 目录） git clone \"https://github.com/plutotree/plutotree.github.io.git\" cd plutotree.github.io.git 安装必要的依赖，以及启动 jekyll # 安装ruby，不使用自带的版本 brew install ruby@2.7 export PATH=\"/opt/homebrew/opt/ruby@2.7/bin:$PATH\" \u003e\u003e ~/.zshrc source ~/.zshrc # 适用bundler做gem包管理 gem install bundler bundle install # 启动jekyll bundle exec jekyll serve 为什么使用 ruby 2.7 参考GitHub Pages 依赖的版本信息，ruby 支持的版本为 2.7.3 ","date":"2021-09-06","objectID":"/2021/09/create-github-blog-using-jekyll/:0:0","tags":["jekyll"],"title":"在github pages上使用jekyll","uri":"/2021/09/create-github-blog-using-jekyll/"},{"categories":null,"content":"思源字体是 Adobe 和 Google 联合开发的开源字体，以 Apache 2.0 授权，可以免费商用。每套字体提供了 7 个尺寸，并且为中日韩，更具体的说大陆、香港、台湾、韩国、日本都进行了针对化的设计，包括思源宋体、思源黑体和思源等宽三类字体。 Adobe和Google采用了不同的命名方式，这里我更喜欢 Adobe 的命名方式。这里的安装方式比较复杂，有多种字体格式：OTF、OTC、Super OTC 和 Subset OTF，还要区分多个区域，可以参考 github 上的文档。Super OTC 包含的种类是最全的，但是一般来说我们只需要SC后缀的版本就够了，在显示简繁体中文、日文、韩文的时候其实都不会缺字。而有这么多复杂的版本原因是不同区域对于同一个字的写法是有差异的。不仅是台湾、香港，日本还有所谓的和制汉字。 思源宋体简体中文下载 思源黑体简体中文下载 思源等宽 最方便的安装办法是使用scoop，只要执行： scoop bucket add nerd-fonts scoop install nerd-fonts/Source-Han-Serif-SC scoop install nerd-fonts/Source-Han-Sans-SC scoop install nerd-fonts/Source-Han-Mono-SC 字体中文名 adobe 字体英文名 google 字体英文名 思源宋体 Source Han Serif Noto Serif CJK 思源黑体 Source Han Sans Noto Sans CJK 思源等宽 Source Han Mono Noto Sans Mono CJK 在使用字体的时候需要注意的是引用的字体名是Source Han Sans SC（SC为简体中文缩写，对应大陆常见写法）。 如果使用的是Source Han Sans，那会使用日文的字体，包含的文字可能不全，另外部分子写法和我们正常的写法也会不一致。 SC：Simplified Chinese (China) TC：Traditional Chinese (Taiwan) HC：Traditional Chinese (Hong Kong) 无：Japan K=Korean ","date":"2020-12-04","objectID":"/2020/12/source-hans-font-intro/:0:0","tags":["fonts"],"title":"思源字体介绍","uri":"/2020/12/source-hans-font-intro/"},{"categories":null,"content":"关于 LaTex LaTeX是一种基于 TeX 的排版系统，而 TeX 是高德纳在发表《计算机程序艺术》的时候，因为当时的排版软件无法达到他的要求，自己编写的（牛人就是这么牛）。LaTeX非常适用于生成高质量的科技文章，在学术界用的较多，期刊杂志都会提供LaTex的模板，对于工科研究生来说算是必备的技能了。LaTeX作为一种标记语言，遵循的一个基本理念就是呈现和内容分离，和现在的 markdown 有点类似。 下面看看一个示例效果吧 对应的代码如下（看着也还好对吧？） \\documentclass{article} \\usepackage[UTF8]{ctex} \\usepackage{amsfonts} \\usepackage{pgfplots} \\pgfplotsset{compat=1.14} \\begin{document} \\title{在Visual Studio Code中使用LaTeX} \\author{PlutoTree} \\maketitle 来个公式： $$ \\int x^{\\mu}\\mathrm{d}x=\\frac{x^{\\mu +1}}{\\mu +1}+C, \\left({\\mu \\neq -1}\\right) $$ 来个函数图： \\begin{center} \\begin{tikzpicture} \\begin{axis}[xlabel=$x$,ylabel={$f(x)$},legend pos=outer north east,axis lines=left] \\addplot[color=red,domain=-3:3,samples=100]{exp(-x^2/2)}; \\addplot[color=blue,domain=-3:3,samples=100]{exp(-x^2/3)}; \\addplot[color=orange,domain=-3:3,samples=100]{exp(-x^2/4)}; \\legend{$\\exp(-x^2/2)$,$\\exp(-x^2/3)$,$\\exp(-x^2/4)$} \\end{axis} \\end{tikzpicture} \\end{center} \\end{document} 对LaTeX感兴趣的话，可以参考相关资料，这里还是先回归正题，有空的话我也会写写LaTeX的使用文章。 ","date":"2020-12-03","objectID":"/2020/12/using-latex-in-visual-studio-code/:1:0","tags":["latex","vscode"],"title":"在Visual Studio Code中使用LaTeX","uri":"/2020/12/using-latex-in-visual-studio-code/"},{"categories":null,"content":"安装 TexLive 目前最新的是TexLive 2020，可以在官网下载在线安装包，不过更建议直接下载完整的 ios 安装包。可以直接点击链接下载，这个地址会自动选择合适的镜像地址。如果发现下载速度很慢，也可以在下述地址中手动选择，或者使用迅雷之类的工具进行下载： 清华大学（北京）：https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2020.iso 北京交通大学（北京）：https://mirror.bjtu.edu.cn/ctan/systems/texlive/Images/texlive2020.iso 上海交通大学（上海）：https://mirrors.sjtug.sjtu.edu.cn/ctan/systems/texlive/Images/texlive2020.iso 中国科技大学（合肥）：https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2020.iso 重庆大学（重庆）：https://mirrors.cqu.edu.cn/CTAN/systems/texlive/Images/texlive2020.iso 腾讯云：https://mirrors.cloud.tencent.com/CTAN/systems/texlive/Images/texlive2020.iso 下载完之后可以直接用资源管理器打开可以直接加载（Windows10 支持，使用虚拟光驱），或者也可以使用压缩工具打开后直接解压缩。不管使用哪种方式，iso 文件或者解压后的文件需要保留，以方便后续安装宏包。 双击运行install-tl-windows.bat 点击Advanced，修改默认的安装路径，然后点击安装 安装包较大，耐心等待 安装完成之后可以直接打开TeXworks editor进行编辑tex文件，以及编译生成pdf。如果能接受TeXworks的丑陋界面，其实可以不用往后看了哈。除了Visual Studio Code之外，也可以选择自己喜欢的任意文本编辑器来使用，包括vim、emacs、notepad++，配置好相关的语法提示，以及快捷命令之后也都可以正常使用。 ","date":"2020-12-03","objectID":"/2020/12/using-latex-in-visual-studio-code/:2:0","tags":["latex","vscode"],"title":"在Visual Studio Code中使用LaTeX","uri":"/2020/12/using-latex-in-visual-studio-code/"},{"categories":null,"content":"配置 Visual Studio Code Visual Studio Code的安装就不介绍了，直接安装插件LaTeX Workshop和LaTeX Utilities 安装完成之后点击LaTex Workshop插件的配置选项 搜索tools，然后选择在settings.json中编辑（这时候会将默认的配置插入） 在前面加上下述参数，不要忘记末尾的逗号 { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-output-directory=%OUTDIR%\", \"%DOCFILE%\" ], \"env\": {} }, 回到插件的配置页面，在上面有Recipes的配置说明，同样点击在settings.json中编辑（这时候会将默认的配置插入），在前面加上下述参数，同样不要忘记末尾的逗号 { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, ","date":"2020-12-03","objectID":"/2020/12/using-latex-in-visual-studio-code/:3:0","tags":["latex","vscode"],"title":"在Visual Studio Code中使用LaTeX","uri":"/2020/12/using-latex-in-visual-studio-code/"},{"categories":null,"content":"使用说明 打开一个文件夹，新建一个 tex 文件，把前面那段代码拷贝进去，点击右上方的箭头进行编译，或者使用快捷键Ctrl+Alt+B，成功之后可以点击左边的View Latex PDF，默认会启动浏览器进行查看。 这时候也可以直接查看文件所在目录，会发现除了生成的pdf文件之外，还有一些其他文件。 ","date":"2020-12-03","objectID":"/2020/12/using-latex-in-visual-studio-code/:4:0","tags":["latex","vscode"],"title":"在Visual Studio Code中使用LaTeX","uri":"/2020/12/using-latex-in-visual-studio-code/"},{"categories":null,"content":"参考资料 TeX Live 下载及安装说明 使用 VSCode 编写 LaTeX 2020 搭建 Latex 环境 ","date":"2020-12-03","objectID":"/2020/12/using-latex-in-visual-studio-code/:5:0","tags":["latex","vscode"],"title":"在Visual Studio Code中使用LaTeX","uri":"/2020/12/using-latex-in-visual-studio-code/"},{"categories":null,"content":"背景 大概是 15 年开始使用1password作为自己的密码管理软件，看中的是多平台同步的功能、方便快捷的密码填充和不错的交互操作，最重要的一点是自己可控的密码库（而不是使用官方的云同步）。最大的一个问题是同步方式只支持 dropbox，每次同步都得搭梯子才能进行。 但是1password在 2016-2017 年开始推出订阅版之后，一开始仍然保留了一次性购买永久授权的方案，并且保持着双版本同步更新。接着独立版更新力度就逐步减弱，重点都放在了订阅版本，毕竟对公司来说订阅版本更加赚钱。windows 的最后一个独立版本的发布时间在 2017 年 9 月份，mac 的最后一个独立版本的发布时间在 2018 年 5 月份。尽管不再更新了，不过对密码管理没特别的诉求，已有的版本功能足够满足需求了，就继续正常使用着。直到有一天突然发现 chrome 的1password插件无法使用了，而这个是重度的使用场景。这个时候只能打开软件手动搜索了，作为拖延症晚期患者没在第一时间去寻找替代方案（其实是找了而没有实施），直到最近换了一个新的手机之后才决定要切换新的密码管理软件。 并没有花太多时间去寻找新选择，很快确定了 bitwarden，开源、多平台、功能齐全，甚至可以自己部署独立服务器，还有什么理由不用它呢。尽管用官方存储不会有什么大问题，一开始也尝试了下，不过选择自己部署会更可控些。 ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:1:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"搭建 web 服务器 拥有一台自己的服务器，拥有一个自己的域名，建议使用一个二级域名作为 bitwarden 服务，下文以bw.yourdomail.com为例。国内域名要走备案流程复杂，国外的话就很方便了。这个流程就不细述了。 申请 https 证书，不得不说acme.sh一键申请\u0026部署证书，真的是太方便了 安装 acme.sh curl https://get.acme.sh | sh 生成证书 这里选择使用 standalone 的方式，需要确保这个域名是未在使用的，如果默认的 80 端口已经被使用，还可以指定其他端口 acme.sh --issue -d xx.yourdomain.com --standalone 拷贝证书：nginx 的配置文件和证书文件放在/etc/nginx.conf/conf.d/目录下 acme.sh --installcert -d xx.yourdomain.com \\ --fullchain-file /etc/nginx/conf.d/xx.yourdomail.com.crt \\ --key-file /etc/nginx/conf.d/xx.yourdomail.com.key \\ --reloadcmd \"systemctl restart nginx\" 用 nginx 实现域名的转发，对于https://xx.yourdomail.com的请求转发至本地的 12345 端口，即后续部署的 bitwarden 服务的端口，nginx 的完整配置文件/etc/nginx/conf.d/xx.yourdomail.com.conf如下: server { listen 443 ssl; server_name xx.yourdomail.com; ssl_certificate conf.d/xx.yourdomail.com.crt; ssl_certificate_key conf.d/xx.yourdomail.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:12345; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } } 这里将请求转发至了本地的 12345 端口（就是我们后面要部署的 bitwarden 服务的地址） ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:2:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"部署 bitwarden 服务 由于官方的服务需要用到 sqlserver，资源占用较大，推荐使用bitwarden_rs，用 ruby 实现的 bitwarden 服务端兼容版本，这就是开源的好处。 不得不说 docker 安装真的是太方便，两句命令搞定：第二句里面我把对外的端口调整成了 12345，而不是默认的 80，就是前面所配置的 nginx 转发目标地址。 docker pull bitwardenrs/server:latest docker run -d --name bitwarden -v /bw-data/:/data/ -p 12345:80 bitwardenrs/server:latest ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:3:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"迁移 1password 的数据 官方的教程说的比较清楚，导入操作很快，有几点提一下： 登录信息比较成功迁移，包括登录密码的历史信息、收藏信息都能比较完整导入到 bitwarden； 安全备注以及密码、会员信息、护照、软件许可、银行账户等类别能成功导入到 bitwarden，不过都是作为安全笔记的类型而存在，除了部分字段外，原始信息基本上都作为了自定义字段进行保存； 这里的自定义字段会存在问题，比如护照的有效期在 1password 里面保存的是时间戳而不是可见的日期格式（这点很合理，因为展现格式是可以更换的），这样导入到 bitwarden 之后就变成了一串数字；比如性别保存的是 male/female，导入后也是这些字符串。bitwarden 自定义类型是只有 text 和 bool 的，没有其他类型！ ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:4:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"使用感受 1password 有非常完善的类型，包含信用卡、护照、银行账户、邮箱、软件 license、服务器、数据库等等，并且每个类型的字段都非常完整。对比而言，bitwarden 只有卡片和身份两个类型，卡片只有信用卡的最基础的几个字段，身份是相对完整的个人信息。所以除了登录密码，bitwarden 维护其他数据还是不太方便。 1password 是或做比较实时地自动同步，而 bitwarden 的自动同步间隔是非常长的，几个小时才同步一次，而且没有发现有自动同步的时间设置选项，官方回复在此，的确没有相关同步时间选项，只能手动同步； 其他待补充 ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:5:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"二步验证（TOTP） TOTP (Time-based One-Time Password) 直接翻译就是有有效期的一次性密码，只是他的场景用在了登录时的二次验证，所以就姑且叫他二次验证吧。对 TOTP 想要了解更多的，这篇文章做了不错的介绍，当然也可以直接看wiki。 官方版本需要付费的 TOTP 功能在自己搭建 bitwarden_rs 服务直接支持了，不过涉及到扫描二维码，相关操作需要用手机上的 bitwarden app 进行。操作很简单，编辑相应的登录项，选择 totp 字段，扫描屏幕二维码，搞定！在实际使用时不会自动切换到 totp 验证码，需要手动拷贝（也可能是我的操作姿势不对？后面再确认） 另外提一句，bitwarden 主账户也是可以打开 totp 的，问题来了，可以使用 bitwarden 来作为自己的 totp 服务么？想象下，你登录 bitwarden 需要验证码，而这个验证码需要进入 bitwarden 才能拿到，是不是死循环了，无法进入了，所以不要这样做，还是选择 authy 或者 google authenticator 吧。 ","date":"2020-03-02","objectID":"/2020/03/bitwarden/:6:0","tags":["bitwarden","password"],"title":"搭建自己的bitwarden密码管理服务器","uri":"/2020/03/bitwarden/"},{"categories":null,"content":"操作步骤 安装蓝牙客户端BluetoothConnector： brew install bluetoothconnector 查找 airpods 的蓝牙地址：按住option键，点击顶部蓝牙图标，找到 AirPods（前提需要先连接上），右侧会有地址信息（好像不能拷贝，手动记录下吧） 创建 alfred 工作流： 打开 alfred 设置页面，选择 workflow 选项，点击左侧底部的加号键，选择Blank Workflow 选择名称、描述、分类，可以选择导入 AirPods 的图片（可以下载这个 AirPods大图），选择Save保存 在新建的 Workflow 下方右键选择 Inputs - Keywords，输入关键字airpods，注意选择No Argument，点击Save保存 拉动刚创建的触发器的右侧，选择Actions - Run Script 输入脚本内容 /usr/local/bin/BluetoothConnector XX-XX-XX-XX-XX --notify，保存即可。顺便说下，这里用了完整路径，开始是直接指定命令字，但是 alfred 提示无法找到。应该是 PATH 环境变量的问题，不过在 alfred 日志里面并未看到echo $PATH的日志输出，有时间的时候再看下问题原因。 触发 alred 之后，输入 airpods 即可连接，并会收到系统通知； 如果已连接的状态下，再次输入 airpods 会触发会触发断开连接，并会收到系统通知； ","date":"2020-03-02","objectID":"/2020/03/connect-airpods-with-alfred/:1:0","tags":["alfred"],"title":"使用alfred连接AirPods","uri":"/2020/03/connect-airpods-with-alfred/"},{"categories":null,"content":"参考资料 Easily connect your AirPods to your Mac with Alfred Workflows ","date":"2020-03-02","objectID":"/2020/03/connect-airpods-with-alfred/:2:0","tags":["alfred"],"title":"使用alfred连接AirPods","uri":"/2020/03/connect-airpods-with-alfred/"},{"categories":null,"content":"关于我","date":"2020-01-01","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"windows10 资源管理器，左侧有较多无用的图标，尤其对于洁癖者来说更想把这些图标都清理干净。 下面先介绍如何移除上面 3 个图标：OneDrive、Dropbox和Creative Cloud Files，然后再介绍移除“此电脑”里面的图标。 ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:0:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"移除 OneDrive 图标 按Win+R，输入regedit，打开注册表编辑器； 进入下述地址（可以直接拷贝到地址栏中） HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6} 将右侧的System.IsPinnedToNameSpaceTree值设置为 0 打开新的资源管理器看看，OneDrive 图标是不是消失了； 如果使用的是 64 位版本的 windows，在运行 32 位程序的时候，还是能在保存对话框里看到 OneDrive。 可以进入注册表编辑器里面的下述地址： HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6} 修改右侧的System.IsPinnedToNameSpaceTree值为 0。重新打开保存对话框，可以发现已经没有 OneDrive 图标了。 如果需要还原的话，将前面操作中的值设置回 1 即可。 ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:1:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"移除 Dropbox 图标 按Win+R，输入regedit，打开注册表编辑器； 进入下述地址 HKEY_CURRENT_USER\\Software\\Classes\\WOW6432Node\\CLSID\\{E31EA727-12ED-4702-820C-4B6445F28E1A}\\ShellFolder 将右侧的Attributes值从f080004d改为f090004d 进入下述地址 HKEY_CURRENT_USER\\Software\\Classes\\WOW6432Node\\CLSID\\{E31EA727-12ED-4702-820C-4B6445F28E1A}\\ShellFolder 将右侧的Attributes值从f080004d改为f090004d 该操作需要重启explorer进程或者注销后重新登录才能生效，也可以选择重启系统。 ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:2:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"移除 Creative Cloud Files 图标 按Win+R，输入regedit，打开注册表编辑器； 按Ctrl+F搜索，输入Creative Cloud Files，找到\\HKEY_CLASSES_ROOT\\CLSID下面的一项 将右侧的System.IsPinnedToNameSpaceTree值从1改为0； 该操作需要重启explorer进程或者注销后重新登录才能生效，也可以选择重启系统。 经过上述 3 个操作之后，左侧的边栏变得清晰了很多，如果有其他程序图标，也可以参考类似的方法移除 ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:3:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"移除此电脑里面的应用图标 优先确认应用本身是否提供了移除图标的功能，如果确认没提供的话，再考虑手动操作。可以先试试点击右键删除是否生效，下面以删除微云同步助手为例 按Win+R，输入regedit，打开注册表编辑器； 进入下述地址 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace 依次查看这里的项，可以通过右侧的信息来确定是否是微云同步助手； 找到后删除该项； 打开新的资源管理器窗口查看是否生效； ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:4:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"移除此电脑里面的 3D 对象 按Win+R，输入regedit，打开注册表编辑器； 进入下述地址 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{0DB7E03F-FC29-4DC6-9020-FF41B59E513A} 右键选择该项删除 进入下述地址（如果是 32 位的 windows 系统则不需要该操作） HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{0DB7E03F-FC29-4DC6-9020-FF41B59E513A} 右键选择该项删除； 上述操作应该可以立即生效； ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:5:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":"快速访问 如果并不需要快速访问展现最近目录和文件的话，可以从配置里面直接关闭 打开文件夹选项 在隐私下去除展现最近文件和文件夹的勾选； 如果不喜欢默认展现快速访问的话，还可以将默认打开配置为此电脑 ","date":"2019-02-01","objectID":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/:6:0","tags":["windows"],"title":"从windows资源管理器中移除左侧边栏图标","uri":"/2019/02/remove-sidebar-icon-from-file-explorer-in-windows/"},{"categories":null,"content":" 腾讯统计已下线，可以查看最后一部分引入百度统计 ","date":"2019-02-01","objectID":"/2019/02/using-baidu-analytics-in-jekyll/:0:0","tags":["jekyll"],"title":"在jekyll中使用百度统计","uri":"/2019/02/using-baidu-analytics-in-jekyll/"},{"categories":null,"content":"操作步骤 加入腾讯统计的方法非常简单，只需要 2 步就可以了： 在腾讯分析申请创建一个项目，得到一段类似代码： \u003cscript type=\"text/javascript\" src=\"http://tajs.qq.com/stats?sId=66171907\" charset=\"UTF-8\" \u003e\u003c/script\u003e 在_includes/footer.html（如果该文件不存在的话，可以从模板里面拷贝出来）最后增加一行，将上面的代码拷贝进去，这时候正常运行就可以得到统计结果了； 百度统计的方式也类似，如果想要在 header 引入的话可以考虑放在_includes/head.html。 这时候本地调试也会上报统计，这种情况如果不想上报的话，需要加上判断条件。这里用了jekyll.enviroment变量，该变量在 github pages 发布的时候会设置成production，而本地没有设置该变量就不会引入该 script。注意下代码的%需要加上对应的{和}（没有直接加是因为会被 jekyll 自动处理） %- if jekyll.environment == 'production' -% \u003cscript type=\"text/javascript\" src=\"http://tajs.qq.com/stats?sId=66171907\" charset=\"UTF-8\"\u003e\u003c/script\u003e %- endif -% 如果你调试的时候想临时验证下的话，可以指定环境变量，类似这样子执行： JEKYLL_ENV=production bundle exec jekyll serve 再进一步，也可以在配置文件里面增加配置项用来配置是否启用腾讯统计或者百度统计。在_config.yml增加一行tencent_analytics: 1，然后在_includes/footer.html里面的条件换成 %- if jekyll.environment == 'production' and site.tencent_analytics == 1 -% ","date":"2019-02-01","objectID":"/2019/02/using-baidu-analytics-in-jekyll/:1:0","tags":["jekyll"],"title":"在jekyll中使用百度统计","uri":"/2019/02/using-baidu-analytics-in-jekyll/"},{"categories":null,"content":"更新 腾讯分析将于 2020 年 12 月 31 日下线，这里引导的腾讯移动分析也将在 2021 年 3 月份下线，所以只能放弃腾讯分析了。 只能切到百度统计了，百度统计的 js 看着有点复杂，先直接拷贝吧。 \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?xxxxxx\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e ","date":"2019-02-01","objectID":"/2019/02/using-baidu-analytics-in-jekyll/:2:0","tags":["jekyll"],"title":"在jekyll中使用百度统计","uri":"/2019/02/using-baidu-analytics-in-jekyll/"},{"categories":null,"content":"jekyll 的kramdown不支持[TOC]自动生成目录的方式，目前了解来看有几种方案： 在正文中添加如下标签，这个方案优点在于不需要额外配置，github pages 也默认支持，缺点在于格式看着不太优雅，不符合markdownlint规范，在visual studio code的 markdownlint 插件下会导致一堆 lint 告警； - TOC {:toc} 使用jekyll-toc插件，这种方式实现比较优雅，也不会破坏 markdown 源文件，缺点在于 github pages 并不支持自定义插件； 在网站的gemfile里面添加一行 gem 'jekyll-toc'，然后执行bundle install 在网站的_config.yml里面添加插件： plugins: - jekyll-toc 在你的 markdown 文件里面的头部分加上toc: true； 使用jekyll html的解决方案，这是目前在 github pages 下推荐的方案； 下载toc.html文件，并放到_includes目录； 在_layouts下用到的html里面，在content前面加上一行% include toc.html html=content %（前后需要加上{ }） ","date":"2019-01-30","objectID":"/2019/01/jekyll-toc-solution/:0:0","tags":["jekyll"],"title":"jekyll自动生成目录的几种方案","uri":"/2019/01/jekyll-toc-solution/"},{"categories":["markdown"],"content":"Markdown 简介 Markdown是一种轻量级标记语言，旨在通过易读易写的纯文本格式来编辑文档，并可转换生成格式化的文档。 Markdown 最早由 John Gruber 于 2004 年创立。2014 年发布的 CommonMark 是第一套严谨的规范。2017 年，GitHub 发布了基于 CommonMark 的 GitHub Flavored Markdown（GFM）的正式规范。 尽管基础的 Markdown 语法简单直观，但不同解析器在实现上多少还是存在差异，特别是对于扩展的 Markdown 语法的支持上。 GFM：目前最流行的 Mermaidarkdown 扩展规范了； Typora：个人认为最好的 Markdown 编辑器和查看器，支持windows和mac，在 GFM 基础上，它还支持很多额外的扩展语法； kramdown：作为jekyll的默认 Markdown 解析器，现在也是 github pages 默认的 markdown 解析器； markdownlint: VSCode 的 Markdown Lint 插件，可以检查语法是否规范； Markdown Preview Enhanced: VSCode 的 Markdown 查看插件，近 700 万的下载次数就能说明其受欢迎程度了； 本文打算以 GFM 和 Typora 为主，来介绍 Markdown 的基础和扩展语法格式规范，以及不同语法在不同解析器下的支持情况，另外还会增加一些markdownlint的规范描述。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:1:0","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"基础语法 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:0","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"标题 使用#指定标题，1-6 个#，分别对应 1-6 级标题。顾名思义，#数目越少，标题级别就越高。按照语法规范，建议#和标题名之间保留一个空格，标题行的前后需要保留一行空行。 # 一级标题 ## 二级标题 ### 三级标题 ###### 六级标题 在生成html时，会对应到\u003ch1\u003e、\u003ch2\u003e、\u003ch3\u003e和\u003ch6\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch6\u003e六级标题\u003c/h6\u003e ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:1","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"正文段落 普通文本直接输入就好，但是文本中的换行是不生效的，即使在编辑器中能看到有换行效果，但是导出生成HTML仍然是不生效的。如果要实现换行的话，需要在行尾加上两个空格。直接用\u003cbr/\u003e的html标签的话，也是能实现换行，不过这就不算是markdown语法了。 如果中间有一行空行的话，则会产生是一个新的段落。换行对应到 html 的\u003cbr/\u003e，段落对应到 html\u003cp\u003e \u003c/p\u003e。 对于下述的Markdown 文本： 这是第一段的第一行（结尾加两个空格） 这是第二行 这是第二段的第一行（结尾没有空格） 这仍然是第二段的第一行 使用Typora生成的HTML如下： \u003cp\u003e \u003cspan\u003e这是第一段的第一行（结尾加两个空格）\u003c/span\u003e \u003cbr/\u003e \u003cspan\u003e这是第二行\u003c/span\u003e \u003c/p\u003e \u003cp\u003e \u003cspan\u003e这是第二段的第一行（结尾没有空格）\u003c/span\u003e \u003cspan\u003e这仍然是第二段的第一行\u003c/span\u003e \u003c/p\u003e 对于行首和行尾的单个空格常见的渲染处理是会被直接忽略。段落之间多行空行也没有意义，保留一行空行即可。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:2","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"字体样式 字体样式 语法 例子 html 粗体(Bold) ** ** 或__ __ 这是粗体 \u003cstrong\u003e\u003c/strong\u003e 斜体(Italic) * * 或_ _ 这是斜体 \u003cem\u003e\u003c/em\u003e 粗斜体(Bold and Italic) *** *** 或___ ___ 这是粗斜体 \u003cstrong\u003e\u003cem\u003e\u003c/em\u003e\u003c/strong\u003e 删除线(Strikethrough) ~~ ~~ 这是删除线 \u003cdel\u003e\u003c/del\u003e 删除线不属于标准的 markdown 规范，但是一般的解析器都会支持。至于使用*还是使用_则看个人习惯，使用*的人更多一些。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:3","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"引用 使用\u003e即可进行引用，对应 html 的\u003cblockquote\u003e\u003c/blockquote\u003e，如果引用需要分多段的的话，可以在中间加一个仅包含\u003e的一行即可。如果中间是一个空行的情况，大部分解析器会将其认为是 2 个引用块，也有部分会将其认为是 1 个引用块，使用中最好尽量避免中间有空行的情况出现。 李白曾经写过 君不见，黄河之水天上来，奔流到海不复回。君不见，高堂明镜悲白发，朝如青丝暮成雪。 人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:4","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"列表 使用*、-或+产生无序列表，使用数字加.产生有序列表，有序列表的数字不一定需要有序，但是需要从 1 开始，也可以所有都是 1。 无序列表： Java C/C++ Python 有序列表： Java C/C++ Python Go PHP 无序列表产生的 html 如下\u003cul\u003e\u003cli\u003e\u003c/li\u003e\u003cli\u003e\u003c/li\u003e\u003c/ul\u003e，有序列表产生的 html 如下\u003col\u003e\u003cli\u003e\u003c/li\u003e\u003cli\u003e\u003c/li\u003e\u003c/ol\u003e 对于多级列表，需要确保子列表与上一级列表的内容对齐，对于有序列表的二级列表缩进 3 个空格（数字+.+空格），对于无序列表的二级列表缩进 2 个空格（-+空格）。对于 list 内部包含段落、引用、代码块、表格等情况，建议和上述规则保持一致。对于上述情况在二级列表或者段落前后包含一个空行。 不同的 markdown 解析器对于列表内包含段落的情况处理的并不一致，所以存在着各种写法，比如段落前用 4 个空格、在上一行末尾加入 2 个空格（软换行）等等，建议保持标准的写法兼容尽量多的解析器。 1. Java Java 连续霸榜 TIBOE 编程语言排行榜，已然成为业界最受欢迎的变成语言。 2. C/C++ - C - C++ 3. Python 4. PHP \u003e 曾经有人说 PHP 是世界上最好的语言 LAMP 曾经是标配，如今已经不再那么流行…… Java Java 连续霸榜 TIBOE 编程语言排行榜，已然成为业界最受欢迎的变成语言。 C/C++ C C++ Python PHP 曾经有人说 PHP 是世界上最好的语言 LAMP 曾经是标配，如今已经不再那么流行…… ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:5","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"链接 链接写法 [展现名](链接地址 \"标题\")，比如腾讯网，其中的\"标题\"可以省略，链接地址可以使用绝对路径也可以使用相对路径，或者指向本地/本网站的其他文件。更进一步，也可以指向本文件的其他锚点（书签），比如跳转引用。 展现的名字和链接地址一致的时候会显得有些冗余，比如[https://www.qq.com](https://www.qq.com)，有更简洁的写法，直接用\u003chttps://www.qq.com\u003e生成https://www.qq.com。 如果多处需要链接相同的地址，我们也可以采用引用的方式，使用[展现名][链接名]，然后在任意地方定义链接名的具体地址 [链接名]: 链接地址，比如腾讯，这样子还有个好处是方便管理。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:6","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"图片 和链接的语法类似，图片需要在前面加上!，常见的写法![展现名][图片地址]，如果需要图片本身也是链接的话，在外层加上链接地址：[![展现名][图片地址]](链接地址) ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:7","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"表格 表格不是标准的 markdown，但是常见的解析器会支持，写法如下，完整的情况会在第一列前面和最后列后面加上|，表头和内容中间需要一行分隔符，这里建议保持和列数一致，某些解析器也会支持最简单的写法---|---（不管多少列的情况下），但是很多解析器并不支持，这里可以通过:来指定表格的对齐方向，左对齐、右对齐还是居中。 表头1|表头2|表头3 :---|:---:|---: 内容|内容|内容 内容|内容|内容 国家 面积 人口 中国 960 万平方公里 14 亿 美国 936 万平方公里 3 亿 俄罗斯 1709 万平方公里 1.4 亿 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:8","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"分隔符 使用---或者***作为分隔符 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:9","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"转义字符 由于一些符号在 markdown 中有了特殊含义，比如我们就是要输入*abc*，并不希望出现斜体的 abc，那么可以使用\\作为转衣符，输入\\*abc\\*，结果为*abc*。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:2:10","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"扩展语法 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:0","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"代码 行内使用`作为起始和终止符，比如printf，代码块使用位于独立行的```作为起始和终止 int main(int argc, char *argv[]) cout \u003c\u003c \"hello world!\" \u003c\u003c endl; return 0; } ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:1","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"任务列表 任务列表（Task List）在 github 中使用非常广泛，语法格式如下，使用x标识为已完成，未完成的情况中间需要包含空格。 - [x] 银行存款超过 1000 万 - [ ] 当上总经理 - [ ] 赢取白富美 银行存款超过 1000 万 当上总经理 赢取白富美 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:2","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"数学公式 数学公式块，使用位于独立行的$$作为起始和终止，比如： $$ f(x)=\\sum^{\\infty}_{n=0}\\frac{f^{(n)}(a)}{n!}(x-a)^n $$ $$ f(x)=\\sum^{\\infty}_{n=0}\\frac{f^{(n)}(a)}{n!}(x-a)^n $$ 行内数学公式，直接使用$作为起始和终止：$\\delta=b^2-4ac$（有些解析器需要使用$$作为起始和终止）。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:3","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"html 标签 可以使用 html 标签实现 markdown 不支持的功能，正常情况下尽量避免使用 html 标签。 在表格内部需要换行的时候，可以加上\u003cbr/\u003e标签； 需要指定样式的时候，可以加上类似\u003cspan style=\"color:red\"\u003e \u003c/span\u003e标签，比如：我是红色； 指定下划线，使用\u003cu\u003e \u003c/u\u003e，比如：我是下划线； ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:4","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"非通用语法 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:5","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"内容目录 使用[TOC]生成自动目录。Typora 支持该语法，GFM 不支持该语法。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:6","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"时序图 使用js-sequence渲染 ```sequence 罗密欧-\u003e朱丽叶: 哈喽 朱丽叶--\u003e罗密欧: 我想你了 罗密欧-\u003e\u003e朱丽叶: 我也想你了 ``` gfm 不支持时序图，Typora 支持。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:7","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"流程图 使用flowchart.js渲染 ```flow st=\u003estart: 开始 cond=\u003econdition: 有房有车 op1=\u003eoperation: 赢取白富美 op2=\u003eoperation: 走向人生巅峰 e=\u003eend: 结束 st-\u003econd cond(yes)-\u003eop1-\u003eop2-\u003ee cond(no)-\u003ee ``` gfm 不支持流程图，Typora 支持。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:8","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"mermaid 图 mermaid相比时序图和流程图来说，功能会更强大，支持时序图、流程图、UML 图、状态图、甘特图等，Typora 支持但是 GFM 不支持。目前来看，使用算是比较广泛了。官网提供了较丰富的例子，Mermaid Live Editor提供了在线编辑以及导出 SVG。 看下用mermaid来画时序图的例子： ```mermaid sequenceDiagram 罗密欧-\u003e\u003e朱丽叶: 哈喽 朱丽叶--\u003e\u003e罗密欧: 我想你了 罗密欧-\u003e\u003e朱丽叶: 我也想你了 ``` ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:9","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"脚标和上下标 可以使用语法 ​[^脚标A]: 这是脚标A来创建角标（需要使用代码块模式），在需要引用的地方使用[^脚标A]进行引用1。Typora 支持该语法，GFM 不支持该语法。 上标和下标没有一致的标准，在 Typora 中使用^文字^表示上标，使用~文字~表示下标，但我看并没有得到广泛支持。建议在 markdown 中尽量避免使用上下标，如果要保持兼容性的话采用 HTML 的\u003csup\u003e文字\u003c/sup\u003e展示上标，使用\u003csub\u003e文字\u003c/sub\u003e的方式展示下标。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:10","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"YAML 头信息 在文件的头部使用使用独立行的---作为开始和终止，其中间部分会作为 metadata，并不会生成可视内容，这本来是jekyll的特殊格式，现在 Typora 也支持该语法（尽管不一定会生成 html 里面的 metadata）。 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:11","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"Github emoji 按文本形式输入类似:smile:，常见的可以直接输入，完整的可以参考列表。Typora 和 github 都支持，vscode 的相关插件不支持。 人：👦👧👨👩👶👵👴👸👮👼👫🚶🏃👯 动物：🐱🐶🐷🐸🐮🐴🐍🐦🐭🐺🐒🐫 表情：😄😢😕😭😂😷😟😉☺️😁😗😮😍 ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:3:12","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"},{"categories":["markdown"],"content":"参考资料 Writing on GitHub/Basic writing and formatting syntax GitHub Flavored Markdown Spec Markdown Guide Markdown Tutorial 这是脚标 A ↩︎ ","date":"2019-01-29","objectID":"/2019/01/markdown-intro/:4:0","tags":["markdown"],"title":"Markdown 语法详解","uri":"/2019/01/markdown-intro/"}]